---
title : 《Effective Java 第三版》读书笔记
notetype : feed
date : 01-02-2021
Tags: Java,读书笔记
---

[原书（非官方翻译）](https://wizardforcel.gitbooks.io/effective-java-3rd-chinese/content/)

[原书附带源码](https://github.com/jbloch/effective-java-3e-source-code)

## 1. 创建、回收对象

- **1. 考虑使用静态工厂方法代替构造方法**
    
    这里的静态工厂方法和设计模式里的工厂方法模式没有一点关系。静态工厂方法和构造方法都用来创建对象。
    **优点**：
    
    1. 静态方法可以有更直观的名字，而构造方法做不到。构造方法只能通过不同的参数类型列表来区别，对API调用方来说不友好。静态方法可以规避这个问题。例如，Java8以前的Date类，构建当前时间的Date要`new Date()`，不够直观，因为不包含『现在』这个语意。而Java8实现的`LocalDateTime`就可以通过`LocalDateTime.now()`来过去当前时间，更直观。
    2. 静态方法不一定每次调用都必须创建一个新的对象。有些类通过不同的方法缓存了若干个对象（通过集合类存起来或者`static final`修饰类属性），很多时候不需要创建新的对象，使用这些缓存的对象就够了，这样性能会更好。例如`Boolean`这个类，它有`valueOf`静态工厂方法和构造方法。`valueOf`的参数是`true`或者`false`，返回`Boolean.TRUE`/`Boolean.FALSE`，这两个都是用`static final`修饰的类属性，即缓存的对象，所以`valueOf`是不会创建新对象的。而`new Boolean()`同样接受true或者false，却每次都返回新创建的对象。每次都创建新的对象对`Boolean`这种对象语意很简单（`true`或者`false`）的类来说是非常浪费的。
    3. 静态方法可以返回其返回类型的任何子类型的对象。这在很多抽象类中可以见到，抽象类本身不能通过构造方法创建对象，但是可以通过静态方法创建自己的实现类。也因此，返回的子类对象甚至可以根据参数不同而返回不同，很灵活。
    
    **缺点**：
    
    1. 只提供静态工厂方法的主要限制是，没有公共或受保护构造方法的类不能被子类化。
    2. 第二个缺点是，API的调用方通常更倾向于去找构造方法，静态工厂方法比较难被找到并使用，即使它们更好用。因此，静态工厂方法的命名应该符合下面的常用规范，这样至少可以让有经验的程序员更快找到它们。
    
    **常用静态工厂方法命名规范**：
    
    - from——A类型转换方法，它接受单个参数并返回此类型的相应实例，例如：`Date d = Date.from(instant)`;
    - of——一个聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：`Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING)`;
    - valueOf——from和to更为详细的替代 方式，例如：`BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE)`;
    - instance或getInstance——返回一个由其参数(如果有的话)描述的实例，但不能说它具有相同的值，例如：`StackWalker luke = StackWalker.getInstance(options)`;
    - create 或 newInstance——与instance 或 getInstance类似，除了该方法保证每个调用返回一个新的实例，例如：`Object newArray = Array.newInstance(classObject, arrayLen)`;
    - get*Type*——与getInstance类似，一般用于在另一个类（如工具类或伴生类）中获取某个类的对象。Type是工厂方法返回的对象类型，例如：`FileStore fs = Files.getFileStore(path)`，其中Files就是工具类。
    - new*Type*——与newInstance类似，一般用于在另一个类（如工具类或伴生类）中获取某个类的对象。Type是工厂方法返回的对象类型，例如：`BufferedReader br = Files.newBufferedReader(path)`;
    - *type*—— get*Type*和new*Type*简洁的替代方式，例如：`List<Complaint> litany = Collections.list(legacyLitany)`;
- **2. 当构造方法参数过多时使用builder模式**
    
    当构造方法的参数不十分多的时候，使用构造方法或者静态工厂方法是合适的，但是参数一多就会有弊端：
    
    1. 如果有很多参数，其中一部分是必须的，一部分是可选的，那么完整地考虑各种传参情况和使用场景会很困难。比如有a, b, c, d, e, f这6个参数，a和b必须，其余可选，其中c和d一般同时使用，d, e和f也常同时使用，那么就需要至少两个构造方法。如果可选参数再多一些呢？
    2. 参数过多时，它们可能会有一些类型相同，这样调用方光看API的方法签名就会很晕，因为参数顺序不够明确。
    
    一种办法是JavaBeans模式，只提供无参构造方法，其他参数需要一个一个手动`setXXXXX`，不仅麻烦，也破坏了类的不可变性（当然，不可变性并不是所有类都必须）。打死我也不写这种代码。
    这个问题最佳解是使用builder模式。顾名思义，Builder模式就是用来build其他类的。对构造参数很多的Target类，在其中添加一个`public static`修饰的Builder类，Builder类包含所有Target类的属性，Builder有一个构造方法，参数是Target类必须的那几个参数。对其他可选参数，Builder类都有一个同名方法（不需要命名为setXXXXX），只干一件事：把Builder对象的这个值设为传参，然后返回自身（Builder）对象。Builder还有一个build方法，用来new出一个Target对象，Target的所有属性copy本Builder对象的属性。在build方法中可以进行参数校验或其他默认的操作。
    Builder模式当然也有其缺陷，它需要在Target类中创建一个额外的类，使用起来也会使代码啰嗦很多（尤其是构造参数并不多的时候），并且创建Target对象之前必须创建Builder对象，可能有微小的性能损耗。但是，相比JavaBeans模式，Builder模式不会破坏Target类的不可变性，并且代码虽然长但是很好读。
    
- **3. 使用私有构造方法或枚类实现Singleton属性**
    
好理解，常见的单例实现方法有3种：
1. 私有构造方法+公共静态INSTANCE属性。优点是API明确表示该类是一个单例：公共静态属性是final的，所以它总是包含相同的对象引用。 第二个好处是它更简单。不过要注意，API调用方实际上可以通过反射`AccessibleObject.setAccessible`来调用私有构造方法，如果要杜绝这种调用，可以在构造方法中检查一下INSTANCE是否已经有值，如果有则抛出异常。

    ```java
    // Singleton with public final field
    public class Elvis{
        public static final Elvis INSTANCE = new Elvis();
        private Elvis() { ... }
        public void leaveTheBuilding() { ... }
    }
    ```

1. 私有构造方法+私有静态INSTANCE属性+公共静态工厂方法。优点是静态工厂方法的具体实现细节可以改动（比如从全局单例改为线程单例）；如果需要，可以编写一个泛型单例工厂（generic singleton factory ）；最后一个优点是，在java 8中，可以用Elvis::getInstance这种函数式方法来表示`Supplier<Elvis>`，很简洁。
    注意，**单例类的所有实例属性（如果有）都要用transient修饰，而且要实现`readResolve`方法，防止序列化、反序列化创造出多个实例**。
    
    ```java
    // readResolve method to preserve singleton property
    private Object readResolve() { 
        // Return the one true Elvis and let the garbage collector 
        // take care of the Elvis impersonator. 
        return INSTANCE;
    }
    ```

1. 单例的最好实现方法是利用单一元素枚举。虽然有些不自然，但是枚举保证了严格的单例，即使是在序列化、反序列化的场景中，而且并不需要实现方考虑这些细节。但是有唯一缺点：**单例类不能继承自Enum以外的任何类，但可以实现接口**。
   
    ```java
    public enum Elvis {
        INSTANCE;
        public void leaveTheBuilding() { ... }
    }
    ```

    [单例拓展阅读](https://app.yinxiang.com/shard/s33/nl/8590904/b581a05e-f573-4a56-976e-8e1c8fe34bbb)
    
- **4. 使用私有构造方法实现非实例化**
    
    有些类只包含类（static）属性、方法，称为工具类或常量类，一般命名为XxxxUtils或者XxxxConstants。这种类一般不需要实例化或者被继承，所以需要让它们非实例化。
    实现方法：使用一个私有的构造方法（防止外部调用），并且构造方法只抛出一个异常（防止内部不小心调用）。然后，应该将它们声明为final的class，防止被继承。
    
- **5. 使用依赖注入取代硬连接资源**
    
    有些类依赖一个或多个其他组件（静态资源或其他服务），这样的类不适合使用单例、非实例化，因为不能一厢情愿地认为这些组件都只有一种实现，往往要在实例化时使用依赖注入来赋值这些组件。
    依赖注入最简单的方法，实际上就是java中的传参构造方法。高级一些的实现主要就是spring IOC了。
    
- **6. 避免创建不必要的对象**
    
    在可以重用对象的时候重用对象，可以避免创建、回收对象的开销，性能更好。这似乎是大家都知道的，但是需要注意的是一些很难被察觉的重复创建对象。
    
    1. 字符串的实例化。字符串字面量（写在程序里的用双引号包起来的字符串）是会被jvm缓存的。比如`"hello"`不管写在哪里，都是一个对象。如果写`"hel"+"lo"`也会在编译时被转化为`"hello"`，所以在运行时还是一个对象。但是如果有`String p1= "hel"`，然后计算`p1+"lo"`，这样是不会被编译器优化的，所以会有3个字符串对象。
    2. 一些API内部隐藏着创建对象，如果只是调用一次还好，如果要循环多次调用，会有性能浪费。这些API一般是方便使用的简单封装，如果多次调用，最好不要直接调用这种API，应该自己去实现底层逻辑。比如，`String.matches`用来判断一个字符串是否符合给出的正则表达式的要求，它会在内部根据正则表达式创建一个`Pattern`对象用于匹配字符串，其中需要将正则表达式编译成有限状态机，这是消耗很大的。如果只是需要匹配一次还好，直接调用`String.matches`和自行写底层逻辑没有区别；但是如果要循环多次匹配，或者在Web环境中每个请求都要匹配，那就太浪费了。解决办法：创建私有静态的`Pattern`对象`private static final Pattern PATTERN = Pattern.compile("...");`然后用这个`Pattern`对象去匹配，这样就只进行了一次性能损耗较大的有限状态机编译。这一点要规避需要对API足够了解，所以在调用API时最好翻翻源码。
    3. 优先使用基本类型而不是装箱的基本类型，也要注意无意识的自动装箱。不想写了。。。
    
    这条建议不要理解为『创建对象都十分昂贵，所以要尽一切可能避免』，实际上，现代JVM创建和回收一个简单对象的消耗是很小的（只有很少的对象是例外，比如上面说的Pattern、JDBC连接、线程等），创建对象来换取程序更好的可读性和安全性是十分划算的。
    可读：一个类如果要避免创建不必要的对象，往往要自行管理一个静态实例池。如果只有几个实例还好，一旦多起来，会让程序不好理解。
    安全：本条目与条目50的防御性复制需要平衡取舍，防御性复制是为了保证程序的安全性，在程序安全、可读的前提下遵循本条『避免创建不必要的对象』。
    
    > 本条目说：“当你应该重用一个现有的对象时，不要创建一个新的对象”，而条目50说：“不要重复使用现有的对象，当你应该创建一个新的对象时。”请注意，重用防御性复制所要求的对象所付出的代价，要远远大于不必要地创建重复的对象。 未能在需要的情况下防御性复制会导致潜在的错误和安全漏洞；而不必要地创建对象只会影响程序的风格和性能。
    > 
- **7. 消除过期的对象引用**
    
    一般来说Java程序不需要自己进行垃圾回收，也不需要每次都消除对象引用。例外是程序而不是JVM进行对象管理的时候，尤其是，用数组、集合类存储对象之后，而且数组、集合类本身又是长期引用（即不会因为无有效引用而被回收）。
    例如，手动使用Object[]来充当栈，capacity=10，size随着存取变化，0<=size<=10。在put了10个对象后，又pop了5个，此时size应该是5。假设pop没有把对象引用置null，只是简单地将size减一。把index<size的那5个对象称为活跃对象，相对的，index>=size的那5个对象称为不活跃对象。这种情况下，不活跃对象不可能再被使用（如果没有其他引用指向它们），但是由于它们被数组的不活跃引用指向，它们永远不会被回收，直到下次被put覆盖掉（可是即使它们被覆盖掉，后面的对象还是会有一样的问题）。这就是典型的程序管理对象，而不是JVM。这个问题叫内存泄漏，看似不严重，但是如果对象足够大，或者capacity足够大，可能会导致OOM。要改正很简单，pop的时候把pop的元素所在的索引引用指向null即可，游离的对象会在合适的时候被JVM回收。
    上例可能不太常见，使用Map来缓存键值对导致内存泄漏可能更常见，也是一样的道理。可以改为使用WeakHashMap来进行缓存，WeakHashMap保证当**key**值除了本WeakHashMap的弱引用外没有其他引用时，可以被JVM回收，也就会让value不再被Map引用（value并不是弱引用，在key被回收后value只是不再被Map引用，可能被回收也可能不，取决于是否有其他引用）。
    
- **8. 避免使用Finalizer和Cleaner机制**
    
    不要依赖Finalizer和Cleaner（Java9引入）机制来回收关键资源！**JVM并不保证及时执行它们，甚至不保证一定会执行它们**。而且，不同的JVM实现不一致，可能在开发JVM上它们工作正常，到了不同环境就出问题了。
    所以关键资源的回收，要通过实现AutoCloseable，在close方法中进行。并且使用时要配合try-with-resources机制。
    
- **9. 使用try-with-resources语句替代try-finally语句**
    
    > 在处理必须关闭的资源时，使用try-with-resources语句替代try-finally语句。 代码更简洁，更清晰，并且生成的异常更有用。 try-with-resources语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用try-finally语句很难做到。
    > 

## 2. 重写通用方法的建议

- **10. 重写equals方法时遵守通用约定**
    
    equals方法是否正常将会影响集合类尤其是Hash相关的集合类的表现。Object提供的equals是基于对象标识（object identity）的，也就是说每个对象都只和自身equal。有时这种工作方式就已经符合预期，equals方法不需要重写，主要是这几种情况：
    
    > 每个类的实例都是固有唯一的。 对于像Thread这样代表活动实体而不是值的类来说，这是正确的。 Object提供的equals实现对这些类完全是正确的行为。类不需要提供一个逻辑相等（logical equality）的测试功能。例如java.util.regex.Pattern可以重写equals 方法检查两个是否代表完全相同的正则表达式Pattern实例，但是设计者并不认为客户需要或希望使用此功能。在这种情况下，从Object继承的equals实现是最合适的。父类已经重写了equals方法，则父类行为完全适合于该子类。例如，大多数Set从AbstractSet继承了equals实现、List从AbstractList继承了equals实现，Map从AbstractMap的Map继承了equals实现。类是私有的或包级私有的，可以确定它的equals方法永远不会被调用。如果你非常厌恶风险，可以重写equals方法，以确保不会被意外调用。
    > 
    
    那么在什么情况下需要重写equals？如果一个类包含一个逻辑相等（ logical equality）的概念，例如2个String对象只要字符序列相同就算逻辑相等（虽然它们可能并不是同一个对象），而且父类还没有重写过equals方法（或者父类的equals方法并不完全适用子类）。
    
    一个特殊情况是对象标识相等和逻辑相等同时满足，也就是说，逻辑上不相等的对象存在且只存在一个，逻辑相等则意味着是同一个对象。这种情况一般是枚举类。
    
    如果要自己实现equals，需要满足这些约定：
    
    - 自反性：对于任何非空引用x，x.equals(x)必须返回true。
    - 对称性：对于任何非空引用x和y，如果且仅当y.equals(x)返回true时x.equals(y)必须返回true。
    - 传递性：对于任何非空引用x、y、z，如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)必须返回true。
    - 一致性：对于任何非空引用x和y，如果在equals比较中使用的信息没有修改，则x.equals(y)的多次调用必须始终返回true或始终返回false。
    - 对于任何非空引用x，x.equals(null)必须返回false。
    
    一个可以实例化的值类型衍生出的子类如果添加了新的实例属性，会导致equals很难有完美的实现。因为子类的equals必须考虑拓展的字段，这样会使`子类对象.equals(父类对象)`返回false，而继承多态会使`父类对象.equals(子类对象)`返回true。因此如果需要对一个值类型进行拓展，而且需要equals足够完美，最好使用组合而不是继承。一个反例是，java原生库中java.sql.Timestamp继承了java.util.Date并添加了一个nanoseconds字段，但是它们的equals方法并不完美，所以不要混用它们。
    
    组合也有需要注意的地方。书中提到了下面这个基于组合拓展的例子，一个不区分大小写的字符串类，在实现equals时，它对o为String的情况做了特殊处理，但是一个不区分大小写的字符串对象`cis.equals(aString)`返回true时，`aString.equals(cis)`会返回false，这无意中就破坏了对称性。由于我们不能修改String的实现，所以修改办法只有一个：把equals中对String的特殊处理去掉。这样似乎让equals弱了一些，但至少保证了对称性，在使用时如果将这个类和String错误混用，会导致编译错误（而不是把问题藏住，到运行时再暴露）。
    
    ```java
    import java.util.Objects;
    
    public final class CaseInsensitiveString {
        //这实际上是基于组合的拓展
        private final String s;
    
        public CaseInsensitiveString(String s) {
            this.s = Objects.requireNonNull(s);
        }
    
        // Broken - violates symmetry!
        @Override
        public boolean equals(Object o) {
            if (o instanceof CaseInsensitiveString)
                return s.equalsIgnoreCase(
                        ((CaseInsensitiveString) o).s);
            if (o instanceof String)  // One-way interoperability!
                return s.equalsIgnoreCase((String) o);
            return false;
        }
        ...// Remainder omitted
    }
    ```
    
    总结下来，实现equals的准则是：
    
    > 使用==运算符检查参数是否为该对象的引用。如果是，返回true。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。使用instanceof运算符来检查参数是否具有正确的类型。 如果不是，则返回false。 通常，正确的类型是equals方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如Set，List，Map和Map.Entry）具有此特性。参数转换为正确的类型。因为转换操作在instanceof中已经处理过，所以它肯定会成功。对于类中的每个“重要”的属性，请检查该参数属性是否与该对象对应的属性相匹配。如果所有这些测试成功，返回true，否则返回false。如果步骤2中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。对于类型为非float或double的基本类型，使用==运算符进行比较；对于对象引用属性，递归地调用equals方法；对于float 基本类型的属性，使用静态Float.compare(float, float)方法；对于double 基本类型的属性，使用Double.compare(double, double)方法。由于存在Float.NaN，-0.0f和类似的double类型的值，所以需要对float和double属性进行特殊的处理。虽然你可以使用静态方法Float.equals和Double.equals方法对float和double基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的Arrays.equals方法。当重写equals方法时，同时也要重写hashCode方法（条目 11）。不要让equals方法试图太聪明。如果只是简单地测试用于相等的属性，那么要遵守equals约定并不困难。如果你在寻找相等方面过于激进，那么很容易陷入麻烦。一般来说，考虑到任何形式的别名通常是一个坏主意。例如，File类不应该试图将引用的符号链接等同于同一文件对象。幸好 File 类并没这么做。在equals法声明中，不要将参数Object替换成其他类型。
    > 
- **11. 重写 equals 方法时同时也要重写 hashcode 方法**
    
    在每个类中，在重写equals方法的时侯，一定要重写 hashcode 方法。如果不这样做，就违反了hashCode的通用约定，会让类无法在HashMap和HashSet这样的集合中正常工作。根据 Object 规范，有以下约定：
    
    > 当在一个应用程序执行过程中，如果在equals方法比较中没有修改任何信息，在一个对象上重复调用hashCode方法时，它必须始终返回相同的值。从一个应用程序到另一个应用程序的每一次执行返回的值可以是不一致的。如果两个对象根据equals(Object)方法比较是相等的，那么在两个对象上调用hashCode就必须产生的结果是相同的整数。如果两个对象根据equals(Object)方法比较并不相等，则不要求在每个对象上调用hashCode都必须产生不同的结果。 但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables）的性能。散列表（HashMap、HashSet等）的工作方式：存入对象时，根据对象的hashCode定位到一个桶，然后通过equals来判断是否同一个对象。如果对象的hashCode都相同，则会使散列表退化为单一桶也就是链表。

    
    实现hashCode方法的规范：
    
    > 不要试图从哈希码计算中排除重要的属性来提高性能。不要为hashCode返回的值提供详细的规范，因此API调用方不能依赖它，可以根据需要改变它的具体实现。
    > 
- **12. 始终重写 toString 方法**
    
    所有有实例属性的类对应该重写toString方法（除非所有实例属性都继承自父类，且父类实现了合理的toString），这不是必须的，但是会对api的易用性、可调试性有好处。
    
- **13. 谨慎地重写 clone 方法**
    
    太长了，懒得看，尽量不要实现Cloneable接口，不要用也不要重写clone方法。
    
- **14. 考虑实现Comparable接口**
    
    好理解，compareTo方法的行为尽量和equals方法一致。
    另外，Comparable接口是泛型的，实现要这样：`public class A implements Comparable<A>`。
    

## 3. 类和接口

- **15. 使类和成员的可访问性最小化**
    
    > 将设计良好的组件与设计不佳的组件区分开来的最重要的因素是，组件将其内部数据和其他组件的其他实现细节隐藏起来。一个设计良好的组件隐藏了它的所有实现细节，干净地将它的API与它的实现分离开来。然后，组件只通过它们的API进行通信，并且对彼此的内部工作一无所知。这一概念，被称为信息隐藏或封装，是软件设计的基本原则。
    > 
    
    信息隐藏的原因、好处：
    
    > 它将组成系统的组件分离开来，允许它们被独立地开发，测试，优化，使用，理解和修改。这加速了系统开发，因为组件可以并行开发。它减轻了维护的负担，因为可以更快速地理解组件，调试或更换组件，而不用担心损害其他组件。虽然信息隐藏本身并不会导致良好的性能，但它可以有效地进行性能调整：一旦系统完成并且分析确定了哪些组件导致了性能问题（条目67），则可以优化这些组件，而不会影响别人的正确的组件。信息隐藏增加了软件重用，因为松耦合的组件通常在除开发它们之外的其他环境中证明是有用的。隐藏信息降低了构建大型系统的风险，因为即使系统不能运行，各个独立的组件也可能是可用的。
    > 
    
    在Java中做到信息隐藏的原则很简单：**让每个类或成员（属性、方法、内部类、内部属性）尽可能地不可访问**。
    
    Java9中添加了模块功能，不在module-info.java中显示导出（export）的包对外部不可访问，但是这个机制是**建议性质**的，如果API调用方不想遵守，他们是有办法来规避的：
    
    > 与四个主要访问级别不同，这两个基于模块的级别主要是建议（advisory）。 如果将模块的JAR文件放在应用程序的类路径而不是其模块路径中，那么模块中的包将恢复为非模块化行为：包的公共类的所有公共类和受保护成员都具有其普通的可访问性，不管包是否由模块导出[Reinhold，1.2]。 新引入的访问级别严格执行的地方是JDK本身：Java类库中未导出的包在模块之外真正无法访问。
    > 
- **16. 在公共类中使用访问方法而不是公共属性**
    
    > 公共类不应该暴露可变属性。 公共类暴露不可变属性的危害虽然仍然存在问题，但其危害较小。 然而，有时需要包级私有或私有类来暴露属性，无论此类是否是可变的。
    > 
- **17. 最小化可变性**
    
    > 不可变类比可变类更容易设计，实现和使用。 他们不太容易出错，更安全。
    > 
    
    实现方法：
    
    1. **把所有的属性设置为private**。 这可以防止客户端获得对属性引用的可变对象的访问权限并直接修改这些对象。
    2. **把所有属性设置为final**。通过系统强制执行，清楚地表达了你的意图。
    3. **不要提供修改对象状态的方法**（也称为mutators），通常是setters。
    4. **确保这个类不能被继承**。 这可以防止粗心的或恶意的子类，假设对象的状态已经改变，从而破坏类的不可变行为。 防止子类化通常是通过final修饰类，但也可以采用静态工厂方法+私有或包级私有的构造方法来允许包内继承，同时拒绝API调用方的继承。
    5. **确保对任何可变组件的互斥访问**。 如果你的类有任何引用可变对象的属性，请确保该类的客户端无法获得对这些对象的引用。 切勿将这样的属性初始化为客户端提供的对象引用，或从访问方法返回属性。 在构造方法，访问方法和`readObject方法`（条目 88）中进行防御性拷贝（条目 50）。
    
    对于一些类来说，不变性是不切实际的。**如果一个类不能设计为不可变类，那么也要尽可能地限制它的可变性。**减少对象可以存在的状态数量，可以更容易地分析对象，以及降低出错的可能性。因此，除非有足够的理由把属性设置为非 final 的情况下，否则应该每个属性都设置为 final 的。把本条目的建议与条目15的建议结合起来，你自然的倾向就是：除非有充分的理由不这样做，否则应该把每个属性声明为私有final的。`CountDownLatch`类是这些原理的例证。 它是可变的，但它的状态空间有意保持最小范围内。 创建一个实例，使用它一次，并完成：一旦`countdown`锁的计数器已经达到零，不能再重用它。
    
- **18. 组合优于继承**
    
    > 继承是实现代码重用的有效方式，但并不总是最好的工具。使用不当，会导致脆弱的软件。 在**包中使用继承是安全**的，其中子类和父类的实现都在同一个程序员的控制之下。对应专门为了继承而设计的，并且有文档说明的类来说（条目 19），使用继承也是安全的。然而，从普通的具体类跨**越包级边界继承**，是危险的。提醒一下，本书（Effective Java）使用“继承”一词来表示实现继承（当**一个类继承另一个类**时）。 在这个项目中讨论的问题不适用于接口继承（当类实现接口或当接口继承另一个接口时）。
    > 
    
    也就是说，谨慎使用继承指的是这种情况：继承别人写的类（而不是接口），并且该类并没有详细的文档说明该类应该如何被继承拓展。接口没这个问题，而且一般接口、抽象类就是提供给API调用方实现、继承的，所以会有详细的文档。
    
    弊端：继承打破了封装
    
    1. 子类的实现依赖父类的实现，如果对父类（可能是API提供的类，反正不是自己写的类）实现不清楚，可能会使子类行为不符合预期。原文中关于Set添加元素计数的例子就是这种情况。
    2. 即使当下对父类的实现很清楚，也无法预期将来父类的改变对子类的影响。即使子类代码完全没有变化，由于调用了父类的方法（通过super），子类的行为不完全可控，打破了封装。
    3. 父类可能添加新的方法，可能会带来两个问题：
        - 如果通过继承来对父类的行为进行一些限制，父类如果添加一个新的方法，在子类也重写它之前，新方法将是不受限制的。
            
            > 假设一个程序的安全性依赖于这样一个事实：所有被插入到集中的元素都满足一个先决条件。如果选择通过对集合进行子类化，然后并**重写所有添加元素**的方法，以确保在添加每个元素之前满足这个先决条件，来确保这一问题。如果在后续的版本中，父类没有新增添加元素的方法，那么这样做没有问题。但是，一旦父类增加了添加元素的新方法，则很有可能由于调用了未被重写的新方法，将非法的元素添加到子类的实例中。这不是个纯粹的理论问题。在把Hashtable和Vector类加入到Collections框架中的时候，就修复了几个类似性质的安全漏洞。
            > 
        - 如果子类继承父类时只是添加了一个新方法，可能不会有上面两个问题，当时，如果父类也添加了一个方法签名相同但是返回类型不同的方法（这导致子类中的方法不会默默重写父类的新方法），子类会编译不通过。如果父类添加了一个方法签名相同返回类型也相同的方法，子类就默默重写了父类的新方法，这就又可能会出现上面两个问题了，更糟的是，子类的方法可能并不满足父类新方法的规约。
    
    解决方法：使用组合。
    
    > 只有在子类真的是父类的子类型的情况下，继承才是合适的。 换句话说，**只有在两个类之间存在「is-a」关系的情况下，B 类才能继承 A 类**。 如果你试图让 B 类继承 A 类时，问自己这个问题：每个 B 都是 A 吗？ 如果你不能如实回答这个问题，那么 B 就不应该继承 A。如果答案是否定的，那么 B 通常包含一个 A 的私有实例，并且暴露一个不同的 API：A 不是 B 的重要部分 ，只是其实现细节。
    > 
    
    关于继承和组合的优缺点，原文中举了一个为Set添加计数功能的例子，看懂就明白了。这里总结一些概念和概要：
    
    1. 组合（composition）：为新类添加一个属性（而不是继承目标类），该属性是目标类的实例引用。新类**可选地**包含目标类所有方法，方法签名完全一致，但只是简单地将实现交给目标类实例引用，这被称为转发（forwarding），这种新类中的方法叫转发方法。**继承和组合实际上都对目标类有所依赖，只不过组合比继承对目标类的依赖更轻、更容易满足：继承依赖于目标类的具体实现，难以保证。而组合只依赖于目标类整体功能是完善的，至于内部怎么实现都无所谓，这很容易保证（因为软件开发中，大家至少会保证自己开发的类功能是完善的，但是自己的类具体要怎么实现，完全自己说了算，对外部没有任何承诺）。**
    2. 在转发类的基础上添加一些功能（通过继承转发类，不是继承目标类）的类叫做包装类，这种设计叫做装饰器模式。有时也被错误地认为是委托（delegation），但是*从技术上讲，除非包装对象把自身传递给被包装对象，否则不是委托[Lieberman86;Gamma95]。*
    3. 包装类不适合在回调框架（callback frameworks）中使用，因为组合意在代理目标类实现一些额外的功能，如果在回调中目标类实例绕过包装类实例直接被操作，包装类的功能就无效或者减弱了。
- **19. 要么设计继承并提供文档说明，要么禁用继承**
    
    > 换句话说，该类必须文档说明**可重写方法**的自用性（self-use）。 对于每个重写方法，文档必须指明其调用哪些其他的可重写方法，以何种顺序以及每次调用的结果如何影响后续处理。（**可重写方法，这里是指非 final 修饰的public或protected方法。**）更一般地说，一个类必须文档说明任何可能调用可重写方法的情况。
    > 
    
    18点中说的是，开发者不要轻易继承别人的类；本条说的是，自己在设计类时，要么不允许被继承，要么尽量文档说明继承时需要考虑的细节。简单来说，有这个几个原则：
    
    1. 如果一个类设计为可继承的，任何public或protected方法，都要文档说明本方法的自用性：自己调用了哪个/些其他public、protected方法。protected方法还要说明，自己一般由哪个/些public方法调用，自己被重写会影响哪个/些public方法（这是因为protected方法自己不能被外部直接调用，只能被public间接调用）。
        
        > 但是，这是否违背了**一个良好的 API 文档应该描述给定的方法是什么**，而不是它是如何实现的呢？ 是的，它确实！这是**继承违反封装**这一事实带来的不幸后果。要文档说明一个类以便可以安全地进行子类化，必须描述清楚那些没有详细说明的实现细节。
        > 
    2. private和default方法不是可重写方法，这意味着子类不能重写它们，因此不必考虑它们被重写而给其他方法带来的影响。可以将不需要对外暴露、逻辑独立、可复用且不允许被更改行为的代码放在private方法中。
    3. *测试为继承而设计的类的唯一方法是编写子类。*通常，哪些方法应该是public的是显而易见的，但是哪些方法可以设置为protected而允许子类重新实现，哪些方法不允许而设置为private是难以确定的。这时，需要通过测试来确定：*三个子类通常足以测试一个可继承的类。 这些子类应该由父类作者以外的人编写。*
    4. 构造方法中不能调用可重写方法，因为如果调用会可能出现这种矛盾：子类构造方法调用父类构造方法，父类构造方法调用可重写方法，可重写方法被子类重写后依赖于子类构造方法执行的初始化操作。这种矛盾会使子类无法正常工作，并归咎于我们设计的可继承类。
        
        > 如果你决定在为继承而设计的类中实现 Cloneable 或 Serializable 接口，那么应该知道，由于 clone 和 readObject 方法与构造方法相似，所以也有类似的限制： **clone 和 readObject 都不会直接或间接调用可重写的方法。**
        > 
    5. ***设计一个继承类需要很大的努力，并且对这个类有很大的限制。***在想清楚一个类该不该设计为可继承（意味着要满足上述要求）之前，如果让它处于可继承却又没有满足上述要求的状态是危险的。***解决这个问题的最好办法是，在没有想要安全地子类化的设计和文档说明的类中禁止子类化。** 有两种方法禁止子类化。两者中较容易的是声明类为 `final`。 另一种方法是使所有的构造方法都是私有的或包级私有的，并且添加公共静态工厂来代替构造方法。 这个方案在内部提供了使用子类*（父类内部子类，见下例）*的灵活性，在条目 17 中讨论过。*
        
        ```java
        public class A {
            private A() {
            }
        
            public static A of() {
                return new A();
            }
        
            static final class B extends A {
                public B() {
                    //内部子类可以访问到上层父类的private构造方法
                    //外部子类不能
                }
            }
        }
        ```
        
    
- **20. 接口优于抽象类**
    
    > Java 有两种机制来定义允许多个实现的类型：接口和抽象类。 由于在 Java 8 [JLS 9.4.3] 中引入了接口的默认方法（default methods ），因此这两种机制都允许为某些实例方法提供实现。 一个主要的区别是要实现由抽象类定义的类型，**类必须是抽象类的子类**。 因为 Java 只允许单一继承，所以对抽象类的这种限制严格限制了它们作为类型定义的使用。 任何定义所有必需方法并服从通用约定的类都可以实现一个接口，而不管类在类层次结构中的位置。
    > 
    
    Java只允许单一继承，因此只能extends一个抽象类，但是可以implements多接口。
    
    抽象类和接口的对比分两个情况：
    
    1. 只有一个方法。这种情况下，抽象类、接口实际上相当于一个属性（比如，歌唱家：唱歌，作曲家：作曲），此时应该定义一个接口，其唯一方法代表该属性的行为。因为属性只是对类的一个方面的修饰，它可能还有其他方面的修饰（类能实现多接口，不能继承多父类）。
    2. 有多个方法。在这种情况下，又分两种情况：
        1. 这些方法的集合是一个不可分割的整体（比如，这些方法是人的所有行为的集合），那么应该定义一个接口包括这些方法。
        2. 这些方法是多个属性（比如，歌唱家、作曲家）方法的汇总（表示一个歌唱家兼作曲家），那么应该定义一个接口extends这个属性各自的接口（接口可以extends多个其他接口）。
        
        Java8开始接口可以提供默认方法实现，但是在设计接口时不要企图为所有方法提供默认方法，只需要为极少数几乎不会被重写的方法提供默认方法。
        
        在多个方法的情况下，每次实现接口都要实现接口的所有方法，这太麻烦，*可以通过提供一个抽象的骨架实现类（abstract skeletal implementation class）来与接口一起使用，将接口和抽象类的优点结合起来。 接口定义了类型，可能提供了一些默认的方法，而骨架实现类在原始接口方法的顶层实现了剩余的非原始接口方法。 继承骨架实现需要大部分的工作来实现一个接口。 这就是模板方法设计模式[Gamma95]。按照惯例，骨架实现类被称为 AbstractInterface，其中 Interface 是它们实现的接口的名称。由于骨架实现类是为了继承而设计的，所以你应该遵循条目 19 中的所有设计和文档说明。好的文档在骨架实现中是绝对必要的，无论它是否包含 一个接口或一个单独的抽象类的默认方法。*
        
        接口中的方法可以定义为`Object`已有的方法，并添加一些说明文档，但不能提供默认的实现，想要做到对这些方法提供默认的实现，必须借助骨架实现类。另外，对于这些方法，实现类无需强制实现，因为`Object`已经默认实现了。
        
- **21. 为后代设计接口？接口要可延续使用**
    
    <aside>
    📌 这一节标题是***Design interfaces for posterity***，即为后代设计接口。实际上说的是，接口设计要在最开始就尽量做好万全的考虑、测试，以保证接口投入使用后不再需要任何改变。
    
    </aside>
    
    在Java8以前，不可能在不破坏现有实现类的前提下给接口添加一个方法，接口添加任何方法都会使现有的实现类不满足`implements` 约束而编译失败。
    
    在Java8中，添加了接口默认方法，可以使实现类默认实现该方法。但是，添加这样一个默认方法是由风险的。例如，Java8为`Collection` 接口添加了`removeIf`默认方法，可以很方便地用一个条件判断`Predicate`来遍历集合，删除其中不满足条件的元素。但是这个方法并不能在所有实现类中正常工作。比如 `org.apache.commons.collections4.collection.SynchronizedCollection` 类，是使用包装（第18条中提到过）类来实现通用的线程安全集合的类。包装的特点决定它会把所有方法都转发到被包装的类（转发），只是在转发外层有一个 `synchronized` 块以实现互斥（并发控制）。在`Collection`接口添加了`removeIf`默认方法之后，由于`SynchronizedCollection` 类没有对其进行并发控制+转发，默认实现的 `removeIf` 实际上是没有并发控制作用的，这会导致`SynchronizedCollection` 类的实例在被**错误地**调用 `removeIf` 时行为不符合预期，甚至可能会运行时失败（即使编译通过了）。
    
    这样的问题看似是因为实现类没有和接口同步升级导致的，似乎`SynchronizedCollection` 类只要在Java8发布时更新一下就ok了？但是作为接口的设计者，我们不能寄希望于在改动接口后要求所有实现类同步升级，不管改动多么小。
    
    > 应该避免使用默认方法向现有的接口添加新的方法，除非这个需要是关键的，在这种情况下，你应该仔细考虑，以确定现有的接口实现是否会被默认的方法实现所破坏。然而，默认方法对于在创建接口时提供标准的方法实现非常有用，以减轻实现接口的任务（详见第 20 条）。
        还值得注意的是，默认方法不是被用来设计，来支持从接口中移除方法或者改变现有方法的签名的目的。在不破坏现有客户端的情况下，这些接口都不可能发生更改。
        准则是清楚的。 尽管默认方法现在是 Java 平台的一部分，但是非常悉心地设计接口仍然是非常重要的。 虽然默认方法可以将方法添加到现有的接口，但这样做有很大的风险。 如果一个接口包含一个小缺陷，可能会永远惹怒用户。 如果一个接口严重缺陷，可能会破坏包含它的 API。
    > 
    
    接口默认方法是、要用来减轻实现的开发难度和开发量，要在设计接口时就考虑到默认方法的使用。而不是在接口已经投入使用后，借用默认方法来改动接口。
    
- **22. 接口仅用来定义类型**
    
    仅使用接口来抽象定义一种类型（如，人、某种动物、某种职业等），不要用来干其他看起来方便但不合适的事情。比如用接口来定义一堆常量。常量完全可以定义到一个常量工具类（第4条提到过）。常量接口违背了接口的设计意图。JDK中就有违背这条规定的接口，比如`java.io.ObjectStreamConstants` 常量接口。
    
    当然，并不是说接口中一定不能出现常量（接口中不能定义实例属性，只能定义常量——`public static`），如果某个常量和这个接口关联十分紧密，那么放在接口里是ok的。
    
- **23. 类层次结构优于标签类**
    
    标签类：用一个类来表示一系列类型，其中一个实例属性为标签字段（tag field），标识某个实例的类型。例如，有一个图形类`Figure` ，用来标识一系列形状的图形，其中有一个标签字段`shape` 来标识实例是圆形circle还是矩形rectangle还是三角形triangle，`shape` 可能用枚举类标识，可能是整数，甚至可能是字符串。
    
    标签类的缺点很多：
    
    1. 代码冗长，杂乱无章，充满了标签字段判断语句。由于标签字段标识了实例的种类，几乎所有实例方法都要通过标签字段来判断应该怎么行为。比如算图形面积、周长都要判断到底是什么形状，不同的形状算法不一样。
    2. 内存占用增加。标签字段需要额外的内存。标签类中有所有类型的特殊字段，也会导致额外的内存占用。比如上例，矩形的长和宽、圆形的半径，都需要在标签类中声明为实例属性。
    3. 违反了开闭原则
        
        > 软件实体应对扩展开放，而对修改关闭
        > 
        
        标签类恰好相反，对拓展不友好，对修改开放。体现在，每次添加一个类型，就要在所有判断标签字段的地方添加一个条件分支。
        
    4. 可读性差。代码的混乱导致可读性差是显而易见的，此外，类名（如`Figure`）不能提供任何实例的种类信息，因为种类是用标签字段标识的。
    
    总结起来，标签类完全就是反面向对象编程，没有利用类层次结构和多态的灵活性。
    
    如果使用类层次结构，将`Figure` 定义为顶层抽象类（或者接口），所有具体的图形都继承`Figure` ，根据各自的特点来实现面积、周长等方法，清晰又独立。而且，添加新的图形不需要改现有代码，添加一个继承`Figure` 的类即可，遵守了开闭原则。
    
- **24. 支持使用静态成员类而不是非静态类**
    
    > 嵌套类（nested class）是在另一个类中定义的类。 嵌套类应该只存在于其宿主类（enclosing class）中。 如果一个嵌套类在其他一些情况下是有用的，那么它应该是一个顶级类。 有四种嵌套类：静态成员类，非静态成员类，匿名类和局部类。 除了第一种以外，剩下的三种都被称为内部类（inner class）。
    > 
    
    由于非静态成员类的实例必须和它宿主类的一个实例相关联，并隐式地持有该宿主类实例的引用，会有额外的内存、时间开销，并且会阻止宿主类实例被垃圾回收，因此除非必要（成员类实例的确需要和宿主类的对象一一关联），优先使用静态成员类。
    
    匿名类一般是`Runnable` 之类的类，创建即用。局部类在方法中声明，只能在它的作用域使用，但是它的对象可以传递出作用域。但是由于作用域外部不知道局部类的存在和它的数据结构，因此除非它实现了某些接口或继承了某个类，这样的传递才有意义，否则只能将它作为`Object`传递。
    
    关于嵌套类和宿主类的互通性：
    
    1. 静态成员类可以有实例成员和静态成员，可以访问宿主类的静态成员（`private`-`public`都可以），不能访问宿主类的实例成员。
    2. 非静态成员类、匿名类、局部类只能有实例成员，可以访问宿主类的静态成员、非静态成员（`private`-`public`都可以）。
- **25. 将源文件限制为单个顶级类**
    
    一个java文件一定只能有一个顶级类，否则非public的顶级类可能在不同的java文件被重复定义。
    

## 4. 泛型

术语                      |  中文含义      |  举例
-------------------------|------------|----------------------------------
Parameterized type       |  参数化类型     |  `List<String>`
Actual type parameter    |  实际类型参数    |  `String`
Generic type             |  泛型类型      |  `List<E>`
Formal type parameter    |  形式类型参数    |  `E`
Unbounded wildcard type  |  无限制通配符类型  |  `List<?>`
Raw type                 |  原始类型      |  `List`
Bounded type parameter   |  限制类型参数    |  `<E extends Number>`
Recursive type bound     |  递归类型限制    |  `<T extends Comparable<T>>`
Bounded wildcard type    |  限制通配符类型   |  `List<? extends Number>`
Generic method           |  泛型方法      |  `static <E> List<E> asList(E[] a)`
Type token               |  类型令牌      |  `String.class`

^559631

- **26. 不要使用泛型类的原始类型**
    
    内容较多，参见原文。总结起来，泛型类的去泛型用法（原文中称为原始类型（Raw Types），要注意这里的原始类型不是int，long等类型（Primitive Types），而是没有尖括号的List）是为了兼容Java5以前的历史代码，带来了很多问题，现在应该尽量避免使用泛型类原始类型。
    
    Java中的泛型在运行时会被擦除，也就是说，只要编译通过，`List<String>`和`List` 在运行时是没有区别的。通配符泛型的限制（**extends能读不能写，super能写不能读**，见 [[Java泛型]]）在运行时也不复存在。这也是为了兼容Java5以前的代码和编译生成的class二进制文件。    
    泛型的意义在于编译时检查，和泛型有关的任何可能的非法操作都会在编译时检查出来，这样就不会把隐患留到运行时。比如原文中提到的，将`List<String>` 强转为`List` 后，可以往`List` 中添加任何`Object` ，但是从列表中读出来赋值给`String` 时会抛出`ClassCastException` ，这一切都不会编译失败（但会有一个警告），但是在运行时就失败了。如果把`List` 换成`List<Object>` ，强转在编译时就会失败。如果确实需要把`List<String>` 强转为某种通用的泛型`List` ，可以用通配符类型（无限制通配符类型`List<?>`、限制通配符类型`List<? super String>`和`List<? extends String>`），`List` 和`List<?>` 的区别在于，前者可以随意添加对象导致运行时类型错误，后者不能添加任何对象，只能读和遍历，保证了安全性。
    
- **27. 消除非检查警告**
    
    在使用泛型编程时经常见到编译器未检查的xxx警告，比如未检查的类型强制转换。对这类警告的策略如下：
    
    1. 尽量用泛型将这些警告一一消除，这样的代码一旦没有警告地编译通过，不会在运行时发生`ClassCastException`报错。
    2. 如果上一点真的做不到，可以**在证明类型安全的前提下**，在**最小的作用域上**使用`@SuppressWarnings(“unchecked”)`来抑制告警。
    3. 每当使用`@SuppressWarnings(“unchecked”)`，用注释说明为什么是类型安全的。
    
    `@SuppressWarnings(“unchecked”)` 不能随意使用，如果在证明某段代码是类型安全的之前就使用，会让开发人员有错误的安全感，但实际上，`ClassCastException` 还是可能在运行时出现。
    
    `@SuppressWarnings(“unchecked”)` 要使用在最小作用域，意味着它的使用作用域优先级是：局部变量、实例属性、类属性、方法参数>方法、构造方法>类。这些作用域都是`SuppressWarnings`的合法作用域。把`SuppressWarnings`放在不合理大地作用域上的坏处是，这个较大作用域中的所有警告都会被隐藏，但可能开发只确认了其中一小部分的类型安全性。
    
    **不要不使用`SuppressWarnings`注解让警告一直出现。**面对类型安全警告正确的做法是：确认类型安全→在最小作用域使用`SuppressWarnings` 消除编译警告→下次再出现类型安全警告时循环。如果只确认类型安全而不使用`SuppressWarnings`，甚至不确认类型安全也不使用`SuppressWarnings`，这样的坏处是，警告一旦多起来，新的警告会藏在已有的警告中，不能被发现，也就不能被确认是否类型安全。
    
- **28. 列表优于数组**
    
    > 数组在两个重要方面与泛型不同。 首先，数组是协变的（covariant）。 这个吓人的单词意味着如果 Sub 是 Super 的子类型，则数组类型 Sub[] 是数组类型 Super[] 的子类型。 相比之下，泛型是不变的（invariant）：对于任何两种不同的类型 Type1 和 Type2，`List<Type1>` 既不是 `List<Type2>` 的子类型也不是父类型。
    > 
    
    但是如果A类型满足`? extends B` 或者`? super B` ，那么`List<A>` 是`List<? extends B>` 或者`List<? super B>`的子类型。
    
    数组的协变性和泛型原始类型有类似的风险，可能把一个`A[]`转换为`Object[]`然后往其中添加不满足`B extends A`的类B，这一切在编译时都检查不出来，但是在运行时会失败，报`ArrayStoreException`错。
    
    > 数组和泛型之间的第二个主要区别是数组被具体化了（reified）[JLS，4.7]。 这意味着数组在运行时知道并强制执行它们的元素类型。 相反，泛型通过擦除（erasure）来实现[JLS，4.6]。 这意味着它们只在编译时执行类型约束，并在运行时丢弃（或擦除）它们的元素类型信息。 
        由于这些基本差异，数组和泛型不能很好地在一起混合使用。 例如，创建泛型类型的数组，参数化类型的数组，以及类型参数的数组都是非法的。 因此，这些数组创建表达式都不合法：`new List<E>[]`，`new List<String>[]`，`new E[]`。
    > 
    
    ```java
    // 为什么泛型类型数组是不允许的？反证法，假设是合法的
    List<String>[] stringLists = new List<String>[1];  //会编译失败，**但是我们假设不会失败**
    List<Integer> intList = List.of(42);               // (2)
    Object[] objects = stringLists;                    // (3)
    objects[0] = intList;                              // (4) 2、3、4都没错
    String s = stringLists[0].get(0);                  // (5) 报错，反证成立
    ```
    
    注意，`new List<E>[]`，`new List<String>[]`，`new E[]`都不能编译成功，但是声明局部变量、实例属性（静态属性不行）为这些类型是合法的，能编译通过。即`List<E>[] eList`等。声明是合法的，`new`是不行的。**但是，`new SomeList<?>[1]`是可以成功创建一个列表的数组的，这是用`new`创建列表数组唯一的办法。**
    
    虽然泛型类数组限制很多，但是数组作为泛型类的类型参数没有限制。如 `new ArrayList<String>[]`不合法，但是`new ArrayList<String[]>()`没有问题。
    
- **29. 优先考虑泛型类**
    
    > 总之，泛型类型比需要在客户端代码中强制转换的类型更安全，更易于使用。 当你设计新的类型时，确保它们可以在没有这种强制转换的情况下使用。 这通常意味着使类型泛型化。 如果你有任何现有的类型，应该是泛型的但实际上却不是，那么把它们泛型化。 这使这些类型的新用户的使用更容易，而不会破坏现有的客户端（条目 26）。
    > 
    
    如果代码中出现了集合类、数组的强制类型转换，要考虑把类泛型化。泛型化的好处是把所有可能的类型错误都提前在编译时发现，而不是藏到运行时才发现。
    
- **30. 优先使用泛型方法**
    
    和泛型类类似，如果某个方法的参数、返回值经常要经过强制类型转换才能使用，可以考虑将这个方法实现为泛型的。泛型方法内部用泛型处理所有类型相关的转换，如果确定需要且没有隐患可以在内部进行强制转换，这样就可以在编译通过时确定这个方法是类型安全的、更可用的。
    
    在非泛型类中定义泛型方法顺序为：方法修饰符、类型参数、返回类型、方法名、参数。其中返回类型和参数可以实泛型类，如果参数中包含泛型类且类型参数正是该方法的类型参数，则调用的时候不用特意指明方法的参数类型，否则，调用的时候要指明类型参数类型。**另外，如果泛型方法是静态方法，且无法根据参数推断出方法的类型参数，那么调用时除了指明类型参数，还必须带上该静态方法所在的类（即使在同一个类中、即使使用了import static）。**
    
    ```java
    public [static] <E> ReturnType methodName(ParamterType p){...}//定义
    method(aP);//如果参数中包含泛型类且类型参数正是该方法的类型参数
    Clazz.<SomeType>method(anotherP);//无法根据参数推断出方法的类型参数
    ```
    
- **31. 使用限定通配符来增加 API 的灵活性**
    
    **使用泛型来在编译期确保程序的类型安全性，使用通配符来增加api的灵活性。**
    
    >这里有一个助记符来帮助你记住使用哪种通配符类型： PECS 代表： producer-extends，consumer-super。　
    换句话说，如果一个参数化类型代表一个 T 生产者，使用`<? extends T>`。PECS 助记符抓住了使用通配符类型的基本原则。 Naftalin 和 Wadler 称之为获取和放置原则（Get and Put Principle）[Naftalin07,2.4]。

    - PE：类型参数的生产者，应该用`extends`来约束其类型参数。
        集合类都有`addAll()`方法，用于批量添加另一个集合中的所有元素，它在`Collection`接口中的定义为：
        ```java
        boolean addAll(Collection<? extends E> c);
        ```
        为什么方法参数是`Collection<? extends E> c`而不是`Collection<E> c`？
        **假设是后者**：有`List<Integer> integerList1` ，要向其中添加另一个整数列表`List<Integer> integerList2`，调用`integerList1.addAll(integerList2)`即可。这种情况下，两个列表类型参数一样，`addAll()`工作正常。但是如果要把`integerList2`添加到一个`Number`的列表`numberList`中，`addAll()`就会出错，因为`numberList.addAll()`接受参数类型`Collection<Number>`及其子类，不接受`List<Integer>`。
        正是因为方法参数是`Collection<? extends E> c`，所以`numberList.addAll(integerList2)`是OK的。因为`List<Integer>`是`Collection<? extends Number>`的子类，却不是`Collection<Number>`的子类。
            
    - CS：类型参数的消费者，应该用`super`来约束其类型参数。
        假设要为`List<E>`添加一个`pollAll(List anotherList)`方法，将其中所有元素添加到`anotherList`中，`anotherList`参数的类型最好是`List<? super E>`而不是`List<E>`，因为要将`E`类型添加到`anotherList`中，`anotherList`可以是任何能够装`E`的`List`，用`List<? super E>`来表示最合适。

    关于限定通配符的语意，以集合类为例，`Collection<? extends E>`应理解为**某个E的子类**（包括E）的集合，而不是一个集合里有各种各样E子类的对象。因为，限定通配符集合一般都是方法参数，在集合被当作参数传入参数之前，创建它的过程一般是某种循环，这样生成的集合的元素要么是同一个类，要么有共同父类，不可能是一个类型`E`没有共同点的父类。同理，`Collection<? super E>`应理解为某个E的超类（包括父类和E实现的接口）的集合。这样就更好理解[[Java泛型]]中的限制了。    
    > 请注意，返回类型仍然是 Set`<E>`。 不要使用限定通配符类型作为返回类型。除了会为用户提供额外（多余？）的灵活性，还强制他们在客户端代码中使用通配符类型。
    
    类型参数的生产者，通常提供类型参数的对象（一个或多个），如方法参数里的`List<E>`。
    
    类型参数的消费者，通常消费或使用类型参数，比如`Comparable<E>`和`Reducer<E>`。
    
    特别的，Java8中随着`Stream`添加的`java.util.function.Function<T, R>`接口，它接受`T`的对象，返回`R`的对象。对于`T`，它是消费者；对于`R`，他是生产者。
    
    **使用PECS的优点**
    
    尝试设计一个`max()`方法，它从一个列表中选出其中最大的元素。
    首先为了通用、类型安全，设计为：
    ```java
    public static <T extends Comparable<T>> T max(List<T> list);
    ```

    这个方法从一个`T`类型的列表中选出一个最大的，`T`是可以和`T`比较的（即同类型比较）。这个方法已经足够通用，但是它不符合PECS原则，对它进行如下改造：
    泛型列表`List`是这个方法的生产者，它提供`T`类型的元素以供遍历比较。根据PE可改造为：
    ```java
    public static <T extends Comparable<T>> T max(List<? extends T> list);
    ```
    
    `Comparable<T>`接口中的`compareTo()`方法是`max()`方法的消费者，它作用于每个元素上进行比较。根据CS可改造为：
    ```java
    public static <T extends Comparable<? super T>> T max(List<? extends T> list);
    ```
    
    改造后的`max()`方法**可以接受T和它子类的列表**，选择出其中最大的元素，**且`T`不一定需要亲自实现`Comparable<T>`**，只要它的任一父类实现过`Comparable`，这个方法就能够正常工作（当然，`Comparable<? super T>`中的`?`会优先匹配`T`本身，其次才是它的其他父类，越近的父类优先级越高）。加粗的两个优点是原来版本不具备的，这说明PECS原则可以让泛型方法更灵活、通用。
    
    **风格：如果类型参数在方法声明中只出现一次，请将其替换为通配符（or not）。**
    
    要设计一个方法`swap()`，交换一个列表中的两个元素位置，要求尽量通用，有下面两种实现：
    ```java
    public static <E> void swap(List<E> list, int i, int j){}
    public static void swap(List<?> list, int i, int j){}
    ```

    哪种更好？先说结论，第一种实现更简单，但是方法签名比较复杂。第二种实现起来麻烦一些，但是方法签名简单。作为公共API，第二种更受推荐。但是这个要求不是强制的，**[统一的风格**比要求本身更重要](https://stackoverflow.com/questions/18142009/type-parameter-vs-unbounded-wildcard)。
    
    下面是解释：
    
    1. 第一种实现中的`E`可以自动匹配任何类型，如果一个`list`中有多种类型，它会匹配它们的共同父类、接口，这好理解。它的缺点是方法签名中出现了`E`和`<E>`，如果作为API，这可能会让不熟悉泛型的使用者有些迷茫。它的优点是实现简单：
        ```java
        public static <E> void swap(List<E> list, int i, int j){
        		list.set(i, list.set(j, list.get(i)));
        }
        ```
    
    2. 第二种用`?`代替了`E`，很好理解它能匹配所有类型（`E`也可以，只是没那么直白），对API使用者更直白。但是实现起来比较复杂，不能像第一种实现那样直接交换两个元素，因为`List<?> list`是不能直接用`set()`来进行写操作的（即使是从它本身`get()`获得的元素）。需要用一个私有帮助方法来实现，帮助方法实现和第一种实现的方法相同。在`swap()`内部调用`swapHelper()`，语意为将`swap()`中的`list`视为同种类型传递给`swapHelper()`，`swapHelper()`中的`list`元素都是`E`，就可以随意`set()`了。在将`List<?>`视为同种类型时，编译器没法找到它们的共同类型或共同父类，因此`swapHelper()`中的`E`被视为`Object`，通过编译。如果`swap()`中类型参数不是`?`而是`? extends ParentClazz`，`swapHelper()`中的`E`会被视为`ParentClazz`。
        ```java
        public static void swap(List<?> list, int i, int j) {
            swapHelper(list, i, j);
        }
        
        //私有的帮助方法
        private static <E> void swapHelper(List<E> list, int i, int j) {
            list.set(i, list.set(j, list.get(i)));
        }
        ```

- **32. 合理地结合泛型和可变参数**
    不同于泛型和数组的不兼容性，可变参数（本质也是数组）和泛型兼容被Java语言设计者接受了，这是因为
    > 具有泛型或参数化类型的可变参数参数的方法在实践中可能非常有用
    
    但是，这也并没有**解决泛型和数组在本质上不兼容**的矛盾，如果在可变参数方法中不合理使用可变参数数组会导致运行时出错。
    ```java
    //这个方法内部不合理使用可变参数数组，运行时会报错
    static void dangerous(List<String>... stringLists) {
        List<Integer> intList = List.of(42);
        Object[] objects = stringLists;
        objects[0] = intList;             // 不报错，但是堆污染
        String s = stringLists[0].get(0); // 运行时报错，ClassCastException
    }
    ```
    
    为了正常的使用泛型可变参数，需要遵守三条约定：
    
    1. 在可变参数的方法内不往可变参数方法数组里存储任何元素，即不写。
    2. 不以任何方式将可变参数数组传递到该方法之外的其他上下文，包括不直接返回、不间接返回、不通过线程间通信机制传递该数组，即只能在方法内部读。
    3. 对满足上诉条件的方法添加`@SafeVarargs`注解，抑制编译器告警。
    
    第一条约定的反例就是上面的例子。第二条约定的反例如下：
    
    ```java
    // 不安全 - 把泛型可变参数数组返回了
    static <T> T[] toArray(T... args) {
        return args;
    }
    
    static <T> T[] pickTwo(T a, T b, T c) {
        switch(ThreadLocalRandom.current().nextInt(3)) {
    			// 问题在这里，编译器会自动把可变参数转换成new一个数组，数组的类型是
    			// **编译器**能感知的**最具体的类型**。在这里，a、b、c都是T，编译器能感知的最具体的类型是
    			// Object（不能是T，因为T不是具体类），于是转换出的代码为：new Object[] { a, b }
    			// 于是toArray方法的参数、返回都是Object的数组。而pickTwo在拿到toArray的返回值后
    			// 会先强制转换为T[]，T是运行时类型String，Object[] -> String[]的转换失败报错。
          case 0: return toArray(a, b);
          case 1: return toArray(a, c);
          case 2: return toArray(b, c);
        }
        throw new AssertionError(); // Can't get here
    }
    
    public static void main(String[] args) {
    		// 会报错
        String[] attributes = pickTwo("Good", "Fast", "Cheap");
    }
    ```
    
- **33. 优先考虑类型安全的异构容器**
    看原文，挺好理解的，不过不太常用。

## 5. 枚举和注解

- **34. 使用枚举类型替代整型常量**
    
    当用到一系列同类型常量（枚举常量）时，考虑用枚举来替代。枚举类更安全（单例，不会静态编译到客户端）、更强大（可以定义更多方法、属性）、更可读（自解释，可以自定义`toString`）。
    
- **35. 使用实例属性替代序数**
    
    如果有将枚举映射到`int`的需求，不要使用枚举自带的`ordinal`方法。它完全依赖代码中枚举的顺序，可能被无意改动后影响已有代码工作。更好的办法是，为枚举类添加一个整数映射值，在初始化的时候手动指定，这样就万无一失了。
    
- **36. 使用 EnumSet 替代位属性**
    
    用`1 << n`来将整数二进制的不同位置1，表示不同的属性（如文本的样式，斜体、加粗、下划线等），称为位属性。
    
    位属性可以通过位运算来高效地完成集合的交并差运算，但是位属性和枚举常量一样有诸多问题，对应地，用`EnumSet`是更好的做法。
    
    `EnumSet`是专为枚举设计的集合，这使它效率高于其他普通集合（存储相同枚举类）。另外，`Collecion`接口声明的`addAll`、`retainAll`、`removeAll`方法也可以用来很方便地进行交并查运算。使用位属性可读性不如`EnumSet`，也不够直观。
    
- **37. 使用 EnumMap 替代序数索引**
    
    如35条所说，使用枚举的序号`ordinal`来标识枚举是不安全的，因为它完全可能被无意改动。如果有需要用枚举作key来索引value，不要把value放在数组里然后用枚举的`ordinal`来当数组的下标，这样不安全也不直观。较好的办法是用35条中提到的自定义顺序来唯一标识枚举，用它来当数组的key。
    
    但是，还有更好的方法——用`Map`。因为枚举自身就满足了`Map`对key的要求（相等、hash等），所以用它来作key是很合理的。虽然可以用其他`Map`来存储枚举索引value，但是更好的方法是使用`EnumMap`，它对枚举做了特殊优化，性能比普通`Map`更好。
    
- **38. 使用接口增强枚举的可拓展性**
    
    枚举不能继承拓展，这是Java语言层级的限制。虽然有时候可以直接往枚举类添加一项，但是这在API中是不合适的，可能会导致客户端工作异常。
    
    一个tricky的方法是，在设计枚举时就使其实现一个接口（例如四则运算符的枚举类，可以实现一个`Operation`接口，它有一个`apply`方法，接受两个值并返回运算结果），在诸如方法参数的地方用接口（`E extends Operation`）来代替枚举类。以后要拓展枚举类时，不改动已有枚举类，添加一个新的枚举类，实现相同的接口。这样可以最大限度地保证客户端兼容性、拓展性。
    

**39. 注解优于命名模式**

- **40. 始终使用 Override 注解**
    
    可以避免因为大意而重载父类方法，而不是重写。
    
- **41. 使用标记接口定义类型**
    
    > 标记接口（marker interface），是不包含方法声明的接口，只是指定（或「标记」）一个类实现了具有某些属性的接口。 例如，考虑 Serializable 接口（第 12 章）。通过实现这个接口，一个类表明它的实例可以写入 ObjectOutputStream（或被「序列化」）。
    
    在创建作用于类的注解时，考虑用标记接口代替。

## 6. Lambda表达式和流

- **42. lambda 表达式优于匿名类**
    
    以往，使用单一抽象方法的接口（或者很少使用抽象类）被用作**函数类型**。 它们的实例（称为函数对象）表示函数（functions）或行动（actions）。 自从 JDK 1.1 于 1997 年发布以来，创建函数对象的主要手段就是匿名类（详见第 24 条）。下面是一段代码片段，按照字符串长度顺序对列表进行排序，使用匿名类创建排序的比较方法（强制排序顺序）：
    
    ```java
    // Anonymous class instance as a function object - obsolete!
    Collections.sort(words, new Comparator<String>() {
        public int compare(String s1, String s2) {
            return Integer.compare(s1.length(), s2.length());
        }
    });
    ```
    
    Java8引入了lambda表达式，可以用来代替函数类型。上面的排序例子如果用lambda表达式来写会简短很多：
    
    ```java
    Collections.sort(words, 
    							(s1, s2) -> Integer.compare(s1.length(), s2.length()));
    ```
    
    lambda表达式比匿名类简洁，而且使用得当也会比匿名类更直观。
    
    但是lambda表达式的问题是没有文档和类名，如果表达式本身不够直观，这个lambda表达式可能不太好理解。因此，lambda表达式内最好只有1-3行代码，如果超过3行，一定要写好注释。
    
- **43. 方法引用优于 lambda 表达式**
    
    所谓方法引用：
    
    ```java
    //lambda
    map.merge(key, 1, (count, incr) -> count + incr);
    //方法引用
    map.merge(key, 1, Integer::sum);
    ```
    
    一般来说，方法引用会比lambda表达式更简洁、更直观（因为方法名会起提示作用）。在发生第42条中讨论的“lambda表达式不得不很长”时，把表达式封装为方法，加上文档和方法名，再使用方法引用，会让代码更可读。
    
    但是如果方法引用并没有比lambda表达式更简洁，也没有比lambda表达式更可读，就不需要使用方法引用。
    
- **44. 优先使用标准的函数式接口**
    java.util.function 包中定义了43个函数型接口，便于开发者使用在lambda表达式、方法引用上。这些接口覆盖了很多常见的逻辑，如果能够复用就不要自己定义一个新的接口，复用JDK的接口可以让代码更可读、可学习。这些函数型接口大致可以定义为下面六大类：

| 类别                | 描述                                                                                                | 方法                | 例子                |
| ------------------- | --------------------------------------------------------------------------------------------------- | ------------------- | ------------------- |
| UnaryOperator`<T>`  | 一元操作，参数与返回类型相同                                                                        | `T apply(T t)`        | `String::toLowerCase` |
| BinaryOperator`<T>` | 二元操作，参数与返回类型相同                                                                        | `T apply(T t1, T t2)` | `BigInteger::add`     |
| Predicate`<T>`      | 谓词演算，根据参数运算出布尔值。且提供了and、or、negate三个布尔逻辑运算方法，便于风格一致的逻辑运算 | `boolean test(T t)`   | `Collection::isEmpty` |
| Function`<T,R>`     | 参数类型和返回类型没有关系的运算                                                                    | `R apply(T t)`        | `Arrays::asList`      |
| Supplier`<T>`       | 生产者，不需要参数                                                                                  | `T get()`             | `Instant::now`        |
| Consumer`<T>`       | 消费者，没有返回                                                                                    | `void accept(T t)`    | `System.out::println` |

- **45. 明智审慎地使用 Stream**
    原文中有一些不该（过度）使用Stream的例子。

-  46-48跳过了

## 7. 方法

- **49. 检查参数有效性**
    
    设计方法时，应使其尽可能通用。 假设方法可以对它接受的所有参数值做一些合理的操作，那么对参数的限制越少越好。 
    
    但是，通常情况下，某些限制是正在实现的抽象所固有的。在这些情况下，方法应该在方法开头显式检查参数有效性，如果无效则用合理的报错结束调用。方法的文档中要写明对参数的限制，并用`@throws`来说明参数异常将引发的报错。
    
    例外情况是有效性检查太过昂贵。
    
- **50. 必要时进行防御性拷贝**
    
    实现一个类A时，如果它有可变类属性b，且这个类的正常工作依赖于可变类属性b不被异常改变，则需要进行防御性拷贝。
    
    不可变类：如`Integer`、`String`等基础类都是不可变类。
    
    可变类：如`java.util.Date`就是可变的（它的不可变改进版为`java.time.instant`）。
    
    不进行防御性拷贝的危害是显而易见的，就算不考虑外部对b恶意的改变，在外部无意中改变b时，也会导致A的实例无法正常工作。
    
    防御性拷贝+不提供`setXxx`方法=不可变类。下面不考虑`setXxx`方法存在的情况，因为提供`set`方法就说明这个类属性是可变的，需要做的是第49条描述的“检查参数有效性”。
    
    **怎么做到防御性拷贝？**
    
    1. 最简单的方法：所有类属性都使用不可变类型。这样在构造之后，内部的属性没有被改变的可能性。
    2. 如果类属性的类型是可变类，则需要做到：
        1. 在构造时，不直接把类属性引用指向传参，而是**正确地拷贝**一个新对象，类属性引用指向新对象。是为防御性拷贝。
        2. 在类方法中不改变类属性。
        3. 在返回类属性的访问器（getter）方法中，再根据已有类属性对象**拷贝**一个新对象，返回新对象。是为防御性拷贝。
        
        注：关于正确地拷贝，构造方法中的防御性拷贝不能用`clone`方法，访问器方法中可以用`clone`方法。具体原因见原文。
    
    一个例子，`Period`类表示一段时间，它有两个类属性`start`和`end`，分别代表开始时间和结束时间。`Period`类完全没有可变的需要，因此要让它不可变。如果`start`和`end`都是`java.time.instant`类型，那很简单，`Period`类自然地不可变。但如果`start`和`end`都是`java.util.Date`类型就需要一些额外的代码来保证不可变：
    ```java
    public class Period {
    	private final Date start;
    	private final Date end;
    
    	public Period(Date start, Date end) {
    		// 防御性拷贝
    		this.start = new Date(start.getTime());
    		this.end = new Date(end.getTime());
    
    		if (this.start.compareTo(this.end) > 0) {
    			// 为什么要先赋值给start、end，再检查类属性的有效性？
    			// 如果想不起来看原文，有解释。
    			throw IllegalArgumentException("...");
    		}
    	}
    
    	public Date getStart() {
    		// 防御性拷贝
    		return new Date(start.getTime());
    	}
    
    	public Date getEnd() {
    		// 防御性拷贝
    		return new Date(end.getTime());
    	}
    }
    ```
    
- **51. 仔细设计方法签名**
    
    看原文吧
    
    - 仔细选择方法名名称
    - 不要过分地提供方便的方法
    - 避免过长的参数列表
    - 对于参数类型，优先选择接口而不是类
    - 与布尔型参数相比，优先使用两个元素枚举类型
- **52. 明智审慎地使用重载**
    
    最容易忘记的一点：**重载（overloaded）方法之间的选择是静态（编译时确定）的，而重写（overridden）方法之间的选择是动态（运行时确定）的。**原文中有个蛋疼的例子来说明这点。
    
    重载的准则：
    
    1. 最好不要有**参数数量**相同的重载方法。
    2. 如果参数数量一样，一定**不要有相同位置的参数类型相近**。相近意味着：继承关系、兄弟关系（继承同一个父类）等。更不可接受的是，如果这种相近的重载方法行为不一致，发生混淆时更让人不解。
    比如`test(String name, int age)`和`test(CharSequence name, int age)`，`String`是`CharSequence`的子类，这样的重载让人看着头大，可能发生编译时类型推断导致方法调用不符合预期的情况。类似的，`test(String name, int age)`和`test(StringBuilder name, int age)`，虽然没有前面那个例子这么恶心，但始终不是一个好的设计。
    jdk中就有一个反例：`List`接口中有两个重载方法`remove(Object o)`和`remove(int index)`，前者移除列表中的元素o，后者移除索引为index的元素。如果不小心把一个`Integer`对象直接传递给`remove`，一般预期的是删除该索引位置的元素（因为`Integer`和`int`一般很少严格区分），但实际上，列表会尝试去移除该`Integer`方法。
    3. 如果参数数量一样，一定不要让参数全都是类似的类型的组合序列。比如`test(String name, int age)`和`test(int age, String name)`只是调换了一下顺序，就算第二个方法的`String`是另外一个参数而不是`name`，这样也是不可接受的。
    
    那么如果有相似的方法，重载却又会违反上面的准则，该怎么办？
    
    1. 方法名不一定要一样
        
        > 例如，考虑`ObjectOutputStream`类。对于每个基本类型和几个引用类型，它都有其`write`方法的变体。这些变体都有不同的名称，例如`writeBoolean(boolean)`、`writeInt(int)`和`writeLong(long)`，而不是重载`write`方法。与重载相比，这种命名模式的另一个好处是，可以为`read`方法提供相应的名称，例如`readBoolean()`、`readInt()`和`readLong()`。`ObjectInputStream`类实际上提供了这样的读取方法。
        > 
    2. 遵守51条中的***对于参数类型，优先选择接口而不是类*** 规定，比如不要写两个参数分别为`String`、`StringBuilder`的重载方法，一个参数类型为`CharSequence`的方法就够了。
- **53. 明智审慎地使用可变参数**
    
    没啥好说的，用可变数量参数有额外的开销，因为要分配、初始化数组。而且在使用可变参数时，要判断数组是否为空。
    
    更好的做法：前3个参数不使用可变参数，而是写3个有1、2、3个参数的重载方法，从第4个开始用可变参数。
    
- **54. 返回空的数组或集合，不要返回 null**
    
    这个很好理解，如果返回null，调用方就需要特殊处理。
    
    返回空集合、Map的最佳实践是`Collections.emptyList`、`Collections.emptySet`、`Collections.emptyMap`。
    
    返回空数组的最佳实践是`new SomeObject[0]`，或者如果为了提高性能，将空数组保存为常量复用，因为空数组是不可变的，所以这样是安全的。
    
    tips：在调用`List#toArray(T[] a)`时，永远**不需要**为参数数组声明合适的大小，直接传空数组就好。声明合适的大小会导致`toArray`方法复用参数数组，反而会降低性能。
    
- **55. 明智审慎地返回 Optional**
    
    `Optional`可以被视为有0个或1个元素的集合，*`Optional` 的本质上是一个不可变的集合，最多可以容纳一个元素。`Optional<T>`没有实现`Collection<T>`接口，但原则上是可以。*
    
    使用`Optional`的场景：方法有可能返回null，只要这个条件成立，就应该考虑使用`Optional`。
    
    除此之外，任何其他地方都不要使用`Optional`。在调用方法返回的`Optional`经过判断后得到真正想要的对象或者抛出异常之后，就不要再使用这个`Optional`，而是使用真正想要的对象，或者处理异常。简单来说`Optional`的声明周期应该是，return前的最多2行代码（创建），到return后的最多5行代码（判断-取值或处理异常）。
    
    创建`Optional`常用方法：
    
    - `Optional.of(someObject)`，不接受null值。
    - `Optional.empty()`，返回空Optional。
    - `Optional.ofNullable(someObject)`，接受null值，参数为null时实际上返回的就是`empty()`。
    
    使用`Optional`常用方法：
    
    - `Optional.isPresent()`，是否有值/非空
    - `Optional.ifPresent(Consumer<? super T>)`，如果有值，进行消费
    - `Optional.get()`，取出值，如果为空则抛出`NoSuchElementException`
    - `Optional.orElse(T)`，如果为空则返回默认值参数，如果非空则返回其值
    - `Optional.orElseGet/orElseThrow`，和上面那个相似，只不过参数都是Supplier，不提前计算出实际的默认值或抛出的异常，只有在确定非空时才计算并返回、抛出。
    
    用`Optional`包装可能返回null的方法返回通常是更优雅的，但是要注意：
    
    - 如果一个方法被声明为返回`Optional`，那它永远不应该返回null，这和`Optional`设计初衷相悖。
    - 不应该把`Optional`和集合类、Map、数组混用，不管是集合类的`Optional`还是`Optional`的集合，都不行。因为`Optional`只应该用在返回可能有空值的情况下，返回集合类、Map、数组的方法如果要返回空，更好的做法不是使用`Optional`，而是返回空的集合类、Map、数组（参见54条）。
    - 不应该使用`Optional`包装`int`、`double`、`long`等基本类型，因为这个包装过程有两次装箱：`int`-`Integer`，`Integer`-`Optional<Integer>`，在性能关键的场景下可能会非常影响。不过，对于`int`、`double`、`long`这三种基本类型，jdk提供了`OptionalInt`、`OptionalDouble`、`OptionalLong`这三种特殊的「Optional」，它们和`Optional`没有继承关系。
    - 最后，在一些使用`Optional`可以让代码更优雅的地方，如果对性能有很高的要求，需谨慎地评估是否使用`Optional`，因为`Optional`相比null检查更优雅，但也有相应的代价——性能损失。
    
- **56. 为所有已公开的 API 元素编写文档注释**

## 8. 通用编程

- **57. 最小化局部变量的作用域**
    
    和第15条类似，
    
    - **用于最小化局部变量作用域的最强大的技术是再首次使用的地方声明它。**
    从C语言过来的程序员喜欢把声明变量都放在方法、代码块的头部，但是这样是没有意义的。在使用变量之前声明、初始化它，这样更可读。因为如果声明和使用隔了很多行，在看代码的时候，不知道声明的代码是在干什么，在使用这个变量的地方又会迷惑这个变量在哪里声明、初始化的。
    - **尽量在声明变量的时候进行初始化。**
    很好理解，这条的例外是，初始化的表达式可能抛出异常，要try-catch。
    
    根据上面两条，再结合for循环、while循环的特点，可以看出for循环比while循环更优：for循环可以在进入循环时初始化若干个相同类型的局部变量，作用域仅限为for循环内。而while循环的边界控制往往需要while循环之外的变量。
    
- **58. for-each 循环优于传统 for 循环**
    传统for循环指的是：
    ```java
    for (int i = 0; i < a.length; i++) {
        ... // Do something with a[i]
    }
    ```
    
    for-each循环指的是：
    ```java
    for (Element e : elements) {
        ... // Do something with e
    }
    ```
    
    一般来说，for-each循环比传统for循环更好，原因是：
    1. for-each循环中，不需要额外的索引计数变量，不易混淆。
    2. for-each循环中，不需要用`a[i]`、`list.get(i)`来取值，不易混淆。
    3. 原文中还举了一个`iterator`嵌套循环的例子，在这种情况下for-each循环比传统for循环更直观。
    
    不过也有传统for循环比for-each循环更适合的场景：
    1. 要删除集合中的部分元素，用for循环+`iterator`可以一边遍历一边删除元素，for-each循环就不行。不过删除集合中的部分元素也可以用集合的`removeIf`方法。
    2. 更新数组、集合的元素的值，for循环可以，for-each循环不行。
    3. 并行迭代：用for循环可以自行规划并行迭代的边界，以保证不重复、不遗漏，for-each循环就不能这样。
    
    除了上面这3中情况，一般都应该优先使用for-each循环。综合57、58条，可以得出：
  > [!tldr]
  > 一般情况下：for-each循环 > for循环 > while循环

  另外，原文里还提到了关于自己实现表示一组元素的类型时的建议：
  > 如果必须从头开始编写自己的 Iterator 实现，那么实现 Iterable 会有点棘手，但是如果你正在编写表示一组元素的类型，**那么你应该强烈考虑让它实现 Iterable 接口**，甚至**可以选择不让它实现 Collection 接口**。这允许用户使用 for-each 循环遍历类型，他们会永远感激不尽的。

  在实现表示一组元素的类型时，至少应该实现Iterator接口，Collection接口相对来说更难实现。

- **59. 了解并使用库**
    
    不要重复造轮子，发扬拿来主义！
    
    另外，原文提到：
    > 从 Java 7 开始，就不应该再使用 Random。在大多数情况下，选择的随机数生成器现在是 ThreadLocalRandom。 它能产生更高质量的随机数，而且速度非常快。在我的机器上，它比 Random 快 3.6 倍。对于 fork 连接池和并行流，使用 SplittableRandom。

- **60. 若需要精确答案就应避免使用 float 和 double 类型**
    
    因为浮点数的存储方式和整数不一样，在特殊情况下会失准。所以在要求精确的场景下应使用int、long、BigDecimal来代替简单浮点数。
    
    使用int、long的好处是性能更好，运算符的支持更好。但需要自行处理原来的浮点数和整数之间的进制差异。例如，处理RMB金额时，用double存储元不好，应该用int、long存储分，并手动处理元和分之间的进制差异（乘以100或除以100）。
    
    BigDecimal表示精确的小数，不需要额外的进制转换，但是性能稍差，也没有运算符支持（java不能重载运算符）。另外，应该用整数或者浮点数的字符串来初始化BidDecimal，不要用浮点数来初始化BidDecimal，避免初始化的时候就引入误差。

- **61. 基本数据类型优于包装类**
    基本数据类型和包装类型有四个主要区别：
    
    1. 基本类型只有值，存储在栈中。包装类型有值对象和引用，引用存在栈中，值对象存在堆中。
    2. 基本类型的值只可能是全功能值（例如`byte`：`-128-127`），包装类的值除了全功能值，还有可能是`null`。
    3. 基本类型比包装类型更省时间和空间。
    4. 非局部变量基本类型的默认值是改类型的默认值，比如`int`是`0`，`boolean`是`false`；非局部变量包装类型的默认值是`null`。
    
    不合理使用包装类型、混用包装类型基本类型容易踩的坑：
    
    1. 比较包装类型是否相等不能用`==`，几乎所有引用类型的相等比较都不能用`==`。
    2. 值为null的包装类型在自动拆箱时会抛出`NullPointerException`。
    3. 包装类型重复和基本类型进行计算的过程中可能会多次装箱、拆箱，导致性能严重下降。
    
    只要有选择，就应该用基本数据类型而不是包装类型，尤其是局部代码的计算逻辑。
    
    但是包装类型也有它的用武之地：
    
    1. 作为泛型的类型参数只能是引用类型，因此基本类型必须用包装类型代替。
    2. 反射方法调用时只能用包装类型。包括在反串行化时，类型只能用包装类型，如`Integer.class`，因为没有`int.class`这么个东西。
    3. 在业务开发中，DTO对象和domain对象中的属性尽量避免基本类型，因为基本类型作为属性时会被赋予默认的初始值，这对db操作、web返回都不太方便。
- **62. 其他类型更适合时，避免使用String**
    1. String不能很好的替代其他类型
    如果值是数字，应该用int、short、long、float、double等类型，而不是String。
    如果值是yes/no，应该用boolean，而不是String。
    如果值是固定范围内的一系列常量，应该定义一个枚举类，而不是用String。
    2. String不能很好的表示多个值的聚合、组合
    比如一个数据由不止一个部分组成，不应该用字符串将这些部分拼接起来（各个部分之间使用分隔符）表示这个数据整体。更优雅、更面向对象的方法是定义一个类专门用来表示这类数据。
    3. String不能很好的实现功能（capabilities）
    原文中举了一个ThreadLocal造轮子的优化过程，用String作为key不安全、不能保证各线程之间数据不冲突，用单独的Key Object作为Key更好。但是最好的方法是，用ThreadLocal变量本身作为key，存到Thread.threadLocals中。
    除了这个例子表达的意思外，还可以看出，预期要唯一、不冲突的对象最好不要用字符串来表示，哪怕直接用最简单的Object都比用字符串好。因为字符串的equals()、hashCode()方法都是基于字符串字面值的判断，而不是`==`判断，这就意味着保证字符串唯一需要更多的工作量而且更不可靠。
- **63. 当心字符串拼接带来的性能损失**
    
    简单来说，使用`+`来拼接n个String，时间复杂度是O(n^2)。作为对比，StringBuilder拼接n个String的时间复杂度是O(n)。这是因为String是不可变的，拼接两个字符串，要把两段复制到一个新的字符串中。可见，除了时间上的损失，内存占用也会比StringBuilder更高。
    
- **64. 通过接口引用对象**
    应该尽量用接口声明参数、返回值、变量、属性，比如
    ```java
    // Good - uses interface as type
    Set<Son> sonSet = new LinkedHashSet<>();
    ```
    
    而不是这样：
    ```java
    // Bad - uses class as type!
    LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
    ```
    
    道理很简单，用接口来声明变量、参数、返回值、属性，尤其是方法的参数、返回值，是一种抽象——抽象带来更广的适用范围、更灵活的可修改性。
    但是，也有不使用接口来声明这些值的情况：
    1. 类型是String、BigInteger这种值类型，使用它们实现的接口（CharSequence、Number）来抽象这些类型一般没有意义，因为这些类基本是专用的，java库都把它们声明为final。当然，也有例外，比如很多操作字符串的库，偶尔也用CharSequence来进行抽象。
    2. 实现接口但同时提供接口中不存在的额外方法的类，如果要使用这些额外的方法，就不应该用接口来进行抽象。
    
- **65. 接口优于反射**
    反射的缺点：
    - 失去了编译时类型检查的所有好处， 包括异常检查。如果一个程序试图反射性地调用一个不存在的类或不可访问的方法，它将在运行时失败，除非你采取了特殊的预防措施。如果不使用反射，这些异常会在编译时失败。
    - 执行反射访问所需的代码既笨拙又冗长。 写起来很乏味，读起来也很困难。
    - 性能降低。
    
    一般来说，正常的代码不需要使用反射，反射最常用的场景是代码分析工具和依赖注入框架。即使在不得不使用反射的场景下，也有更好的方法来使用它：通过反射-构造器创建对象，然后用对象的接口、超类来引用对象，后面就可以像正常代码一样使用对象了。
    
- **66. 明智审慎地使用本地方法（JNI）**
    使用本地方法的理由一般有：
    - 调用JVM宿主平台的特性机制，一般只能用C语言或者C++。
    - 为了使用别的语言的高性能库，比如在Java中如果想利用openssl的现成算法，就要用JNI。
    
    但是，随着Java核心库、三方库的完善，Java已经支持调用越来越多的特定平台的特殊机制，常用高性能库也有了Java原生的实现，JNI不再那么必要。
    
    应该尽量避免使用JNI，因为JNI有以下缺点：
    - JNI不安全：C和C++的内存管理方式不如Java简单，如果出严重问题会导致整个Java的应用不能正常工作。
    - JNI难以调试。
    - JNI的可移植性不够好。
- **67. 明智审慎地进行优化**
    > 总而言之，不要努力写快的程序，要努力写好程序；速度自然会提高。但是在设计系统时一定要考虑性能，特别是在设计API、线路层协议和持久数据格式时。当你完成了系统的构建之后，请度量它的性能。如果足够快，就完成了。如果没有，利用分析器找到问题的根源，并对系统的相关部分进行优化。第一步是检查算法的选择：再多的底层优化也不能弥补算法选择的不足。根据需要重复这个过程，在每次更改之后测量性能，直到你满意为止。

- **68. 遵守被广泛认可的命名约定**
    1. 包名、模块名应该用公司、组织的Internet域名倒排开头。比如腾讯就可以用`com.tencent.`开头。
    2. 域名之后应该用尽量简短的名词（鼓励用缩写）来细分子包。用单数还是复数？查到这样一条规则：*对于同性质的内容用复数包名，不同类型的内容用单数。*有点道理，不过不易实施，所以尽量用单数吧。
    3. 类、接口、枚举、注解的名字应该由一个或多个单词以驼峰形式组成，每个单词首个字母都大写。方法、变量的名字和类差不多，唯一区别是名字的第一个字母小写。
    4. 专有名词缩写，如HTTP、URL、URI等，如何命名并没有统一标准，但至少要保证一条：**能够清晰地分辨缩写和非缩写以及缩写之间的界限，也就是要易读。**比如，`HttpUrl`明显要比`HTTPURL`好。变量名、方法名中的开头单词如果是专有名词，那专有名词的首字母也得小写。
    5. 常量：用final修饰的类、实例属性，如果是基本类型或者不可变引用类型，那它就是常量。常量的命名规则：所有字母均大写，单词之间用下划线`_`来分隔。一般来说，**枚举中的枚举值也是常量，也适用常量的命名规则。**
    6. 局部变量基本和变量、方法的命名方式类似，但是可以适当使用诸如`i、j、num、no`之类的通用单字母、缩写。**方法入参是例外，入参一定要和变量名、方法名一样严格命名。**因为方法入参会直接影响方法文档、代码的可读性。
    7. 类型参数名通常是大写单字母，如果用单词，可能会让人误认为是常量。一般来说，`T` 表示任意类型，`E` 表示集合的元素类型，`K` 和 `V`表示 Map 的键和值类型，`X` 表示异常，函数的返回类型通常为 `R`。

## 9. 异常

- **69. 只针对异常的情况下才使用异常**
    不要用Exception来实现流程控制，也不要编写强迫其他人用Exception来控制流程的API。
    不用Exception来进行流程控制的原因：
    
    1. 不优雅，这不是它被设计用来干的事情。
    2. 效率低，try-catch效率低，并且几乎没有JVM对异常处理进行特殊优化。相比之下，JVM一般会尝试对正常的流程控制进行优化。
    3. 难懂，没有人想看到这样的代码，如果真的出现，它会很费解。
    
    一个易懂的例子：`Iterator`应该在每次调用`next()`方法之前用`hasNext()`方法检查一下状态，这是正确的用法。但是如果只是在无限循环里不停地调`next()`方法，在外层catch住`NoSuchElementException`异常，貌似也能完整的遍历整个`Iterator`，但是这样就是用Exception来进行流程控制，低效且丑陋。
    
    在编写`Iterator`这种（有一个**状态相关的方法**可能无法正常返回的）API时，有两个选择：
    1. 提供一个状态测试方法（比如`hasNext()`），在条件不满足时，状态测试方法返回false，这时不应该继续调状态相关的方法（`next()`），如果调了，抛出异常。
    2. 在不能正常返回时返回一个`Optional`（详见第55条）。
    
    这两个解决方案，除了状态相关的方法和状态测试方法之间可能发生同步互斥不一致的情况下应该使用`Optional`方法，其他情况都应该优先使用状态测试方法+状态相关方法的方案。
    
- **70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常**
    
    Java 程序设计语言提供了三种 throwable：受检异常（checked exceptions，也就是普通的Exception）、运行时异常（runtime exceptions）和错误（errors）。
    
    对于可恢复的情况，抛出受检异常；对于程序错误，抛出运行时异常。不确定是否可恢复，抛出为受检异常。不要定义任何既不是受检异常也不是运行异常的抛出类型。建议在受检异常上提供方法，以便协助程序恢复。
    
    > 因为受检异常往往指明了可恢复的条件，所以对于这样的异常，提供一些辅助方法尤其重要，通过这种方法调用者可以获得一些有助于程序恢复的信息。例如，假设因为用户资金不足，当他企图购买一张礼品卡时导致失败，于是抛出受检异常。这个异常应该提供一个访问方法，以便允许客户查询所缺的费用金额，使得使用者可以将这个数值传递给用户。关于这个主题的更多详情，参见 75 条。
    > 
- **71. 避免不必要的使用受检异常**
    
    受检异常会让API可用，但是不必要的受检异常对于API使用者是一种负担。因为受检异常必须try-catch捕获，而且在Java8中，抛出受检异常的方法也不能在Stream里直接使用。
    
    **如果正确地使用API，且API的使用者可以根据异常信息采取有效的应对，抛出受检异常才有意义。**如果这两个条件不满足，则应该使用未受检异常。一个简单的标准：如果API使用者try-catch异常之后除了将它包装成RuntimeException重新抛出，或者直接退出整个会话、程序之外没有更好的做法，则抛出一个受检异常是没意义的，应该使用未受检异常。
    
    参考第69条中的两个避免Exception的方法，也可以用状态、参数测试方法或者返回Optional来避免受检异常。
    
- **72. 优先使用标准的异常**
    1. 如果Java平台类库提供的Exception符合需要，不要自定义新的Exception。
    2. 不要直接使用Exception、RuntimeException、Throwable、Error。
    
    异常                              |  使用场合
    ---------------------------------|--------------------------
    IllegalArgumentException         |  非 null 的参数值不正确
    IllegalStateException            |  不适合方法调用的对象状态
    NullPointerException             |  在禁止使用 null 的情况下参数值为 null
    IndexOutOfBoundsExecption        |  下标参数值越界
    ConcurrentModificationException  |  在禁止并发修改的情况下，检测到对象的并发修改
    UnsupportedOperationException    |  对象不支持用户请求的方法

- **73. 抛出与抽象对应的异常**
    
    如果方法抛出的异常与它所执行的任务没有明显的联系，这种情形将会使人不知所措。当方法传递由低层抽象抛出的异常时，往往会发生这种情况。
    
    为了避免这个问题， 更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法称为**异常转译** (exception translation)。
    
    比如：实现一个google查询的API，搜索-`search()`方法底层会通过HTTP进行网络连接并查询。如果底层抛出一个HTTP异常，例如timeout之类的，那么这个API应该将其包装为一个诸如GoogleSearchException的异常。
    
- **74. 方法抛出的每个异常都需要创建文档**
    
    用Javadoc的`＠throws`标签描述方法抛出的每一个受检异常，且细化到每一个异常。不要抛出若干个异常，却只描述了他们的共同父类（最大公约数）。
    
    未受检异常不要用这个方法文档化。
    
    如果一个类的大多数方法在同一种情况下会抛出同一个异常，也可以在类上用`@throws`来统一描述，这样的话，就不用在方法上重复描述了。
    
- **75. 在异常消息中包含失败-捕获（failure-detail）信息**
    
    失败捕获信息也就是方便开发、调试定位、分析异常的一些关键信息。区别于向用户展示的异常提示。
    
    这条在日常开发中很重要，失败-捕获信息除了用于丁文、分析异常，还可以包含一些用于方便进行重试的信息，比如常见的userId、orderNo等。
    
    另外，因为诊断、修复软件问题的过程中可能会有不少人参与，因此失败捕获信息不要包含太隐私的东西。
    
- **76. 保持失败原子性**
    
    这节有点复杂，详细可以看原文。
    
    通过抛出受检异常，API对象暗示使用者捕获异常并恢复到正常的状态，使用者因此会预期API对象能够进行接下来的操作，即API对象需出于可用的状态，即使是在抛出受检异常之后。
    
    也就是说，**抛出受检异常之前、之后，API对象都应该出于可用状态，这就是失败原子性**。
    
    有两类对象天生就有失败原子性：无状态（可变实例变量）对象和不可变对象。无状态对象就比如web应用里的大多数Service，不可变对象就比如String。
    
    如果是可变的有状态对象，想要保证失败原子性就比较麻烦了，有如下几个建议：
    
    1. 操作前先校验参数、状态，在修改状态前抛出可能的异常。
    2. 通过1的校验后，在修改状态时，也先进行可能发生异常的修改。
    3. 如果1、2还不能保证失败原子性，可以在对象的拷贝上进行修改，就算发生异常也不会影响原对象。
    4. 最后一种方法是写一段恢复代码，这就和事务性有点像了。
    
    失败原子性并不是强制要求，在代价太大的情况下可以适当取舍，但是应该在文档中加以说明——这个API是否具有失败原子性？如果没有，发生异常时对象会出于什么状态？
    
    大量现有的API并未做到这一点，以后如果有可能要注意。
    
- **77. 不要忽略异常**

## 10. 并发

- **78. 使用synchronized关键字访问共享的可变数据**
    
    `synchronized`关键字保证一个方法、代码块在同一时刻只能被一个线程执行。因此很多人认为它的作用只是互斥。
    
    > 互斥意味着：假设一个过程会使对象的状态从A→b→c→D，b、c是中间（不一致）状态，如果这个过程是互斥的，那么当一个线程执行它时，不会有其他线程观察到对象出于b、c状态——其他线程只能观察到对象处于A（初始）状态或者D（结束）状态。
    > 
    
    这个想法是正确的，但不够全面：`synchronized`除了让方法、代码块互斥，还可以保证进入该方法、代码块的线程可以观察到所有此前在相同锁下进行的修改，简称可见性。
    
    为了利用`synchronized`的可见性，读写代码块、方法都要用相同的`synchronized`锁进行声明。
    
    当然，使用`synchronized`绝大多数时候是为了利用它提供的互斥性。如果只是需要可见性，将共享变量声明为`volatile`更合适。`volatile`保证变量的所有修改都对所有线程实时可见，还保证变量的操作不会被JVM重排序（[参考](http://tutorials.jenkov.com/java-concurrency/volatile.html)）。但是应该警惕：`volatile`不提供原子性，任何想用`volatile`来实现计数器的想法都是错的，想并发计数，应该用`AtomicInteger`或者`AtomicLong`，它们不依赖锁（因此性能更好）且保证原子性。
    
- **79. 避免过度同步**
    
    > 总的来说，为了避免死锁和数据破坏，永远不要在同步代码块、方法里调用外部传递进来的广义函数（函数接口对象、Runnable、Callable等）。
    更通俗的讲，同步块里干的事应该尽量少。在设计一个可变类时，总是要考虑是否需要实现同步。在现在这个多核时代，避免过度同步比以往任何时候更重要。只有在理由充分时才进行同步，并在文档中解释这么做的原因。
    > 
- **80. executor 、task 和 stream 优先于线程**
    
    这个老生常谈了，当需要线程池来并发执行任务时，不应该直接用Thread或者自己写个线程池，应该用`java.util.concurrent.Executors`提供的一系列工厂方法，或者直接用`java.util.concurrent.ThreadPoolExecutor`创建想要的线程池。
    
    不应该直接使用Thread的原因：职责划分
    
    > 当直接使用线程时， Thread 是既充当工作单元，又是执行机制。在 Executor Framework 中，工作单元和执行机制是分开的。现在关键的抽象是工作单元，称作任务（ task ） 。任务有两种：Runnable 及其近亲 Callable （它与 Runnable 类似，但它会返回值，并且能够抛出任意的异常） 。执行任务的通用机制是 executor service 。如果你从任务的角度来看问题，并让一个 executor service 替你执行任务，在选择适当的执行策略方面就获得了极大的灵活性。
    > 
    
    不应该自己重复造线程池轮子的原因：Java类库提供的Executor框架之于执行任务，就像Collection框架之于集合。我们不会自己重复造集合的轮子，也不应该重复造线程池的轮子。
    
- **81. 并发工具优于 wait 和 notify**
    
    正确地使用wait和notify机制进行同步互斥很麻烦，因为这东西比较原始。应该优先用高级一些的并发类库。
    
    > `java.util.concurrent` 中更高级的工具分成三类： Executor Framework 、并发集合（Concurrent
    Collection）以及同步器（Synchronizer），Executor Framework 只在第 80 条中简单地提到过，并发集合和同步器将在
    本条目中进行简单的阐述。
    > 
    
    并发集合指的是`ConcurrentMap`这种，它们的性能比`Collections.synchronizedMap()`高。
    
    同步器包括：`CountDownLatch` 、 `Semaphore`、`CyclicBarrier`、`Exchanger` 以及功能最强大（也最复杂）的`Phaser`。
    
- **82. 文档应包含线程安全属性**
    
    API的线程安全分为几个等级：
    
    - **不可变的** — 这个类的实例看起来是常量。不需要外部同步。示例包括 String 、 Long 和 BigInteger （详
    见第 17 条）。
    - **无条件线程安全** — 该类的实例是可变的，但是该类具有足够的内部同步，因此无需任何外部同步即可并发地使
    用该类的实例。例如 AtomicLong 和 ConcurrentHashMap 。
    - **有条件的线程安全** — 与无条件线程安全类似，只是有些方法需要外部同步才能安全并发使用。示例包括
    Collections.synchronized 包装器返回的集合，其迭代器需要外部同步。
    - **非线程安全** — 该类的实例是可变的。要并发地使用它们，客户端必须使用外部同步来包围每个方法调用（或调
    用序列）。这样的例子包括通用的集合实现，例如 ArrayList 和 HashMap 。
    - **线程对立** — 即使每个方法调用都被外部同步包围，该类对于并发使用也是不安全的。线程对立通常是由于在不
    同步的情况下修改静态数据而导致的。没有人故意编写线程对立类；此类通常是由于没有考虑并发性而导致
    的。当发现类或方法与线程不相容时，通常将其修复或弃用。第 78 条中的 generateSerialNumber 方法在没
    有内部同步的情况下是线程对立的，如第 322 页所述。
    
    在文档没有明确说明API线程安全性、等级的情况下，不应该根据方法签名（synchronized）或者实现来揣测。
    
- **83. 明智审慎的使用延迟初始化**
    
    延迟初始化指的是在第一次使用一个属性时才初始化它，也就是说——如果不用就永远不会初始化。
    
    延迟初始化一般在初始化一个属性成本特别高，或需要特定条件才能初始化的情况下使用，其他情况应该尽量避免，因为它会带来并发的问题。
    
    实例属性的延迟初始化：
    
    最简单的延迟初始化——单检查，因为没有严格的并发控制所以在高并发的情况下，可能重复初始化（但不会太多次）。
    
    ```java
    //单检查：无严格的并发控制，可能重复初始化。
    private volatile FieldType field; //如果是除long、double之外的基本类型，可以去掉volatile
    private FieldType getField() {
        FieldType result = field;
        if (result == null)
            field = result = computeFieldValue();
        return result;
    }
    ```
    
    双检查延迟初始化，严格的并发控制，不会重复初始化，双检查模式比直接的synchronized方法性能好一些。
    
    ```java
    private volatile FieldType field;
    private FieldType getField() {
        FieldType result = field;
        if (result == null) { // First check (no locking)
            synchronized(this) {
                if (field == null) // Second check (with locking)
                    field = result = computeFieldValue();
            }
        }
        return result;
    }
    ```
    
    静态属性的延迟初始化：借用一个静态内部类的私有静态属性可以方便做到延迟初始化，利用了Java类加载的机制。
    
```java
private static class FieldHolder {
    private static final FieldType field = computeFieldValue();
}

private static FieldType getField() {
    return FieldHolder.field;
}
```
    
- **84. 不要依赖线程调度器**
    
    每个操作系统都有自己的独特的线程调度器，为了代码可移植，不应该让具体实现依赖某个特定操作系统的线程调度器。
    
    相同的道理，也不应该用`Thread.yield()`和线程优先级来修复多线程程序，在不同的JVM上它们的表现可能有很大差异。
    
    > 编写健壮、响应快、可移植程序的最佳方法是**确保可运行线程的平均数量不显著大于处理器的数量**。这使得线程调度器几乎没有选择：它只运行可运行线程，直到它们不再可运行为止。即使在完全不同的线程调度策略下，程序的行为也没有太大的变化。注意，可运行线程的数量与线程总数不相同，后者可能更高。正在等待的线程不可运行。
    保持可运行线程数量低的主要技术是让每个线程做一些有用的工作，然后等待更多的工作。**如果线程没有做有用的工作，它们就不应该运行**。 对于Executor 框架（详见第 80 条），这意味着适当调整线程池的大小 [Goetz06, 8.2]，并保持任务短小（但不要太短），否则分派的开销依然会损害性能。
    > 
    
    线程不应该出于忙等待（无限循环检查、等待一个条件满足）中，这会导致它占着CPU资源，并且容易收到线程调度器的影响。
    

## 11. 序列化

- **85. 优先选择 Java 序列化的替代方案**
    
    使用Java序列化（`Serializable`接口）的隐患：
    
    1. 可能发生远程代码执行。
    2. 可能被拒绝服务攻击。
    
    比如下面这段代码产生的字节流，字节流并不长，但是将其反序列化消耗的时间、CPU资源都是服务器无法忍受的：
    
    ```java
    static byte[] bomb() {
        Set<Object> root = new HashSet<>();
        Set<Object> s1 = root;
        Set<Object> s2 = new HashSet<>();
        for (int i = 0; i < 100; i++) {
            Set<Object> t1 = new HashSet<>();
            Set<Object> t2 = new HashSet<>();
            t1.add("foo"); // Make t1 unequal to t2
            s1.add(t1);
            s1.add(t2);
            s2.add(t1);
            s2.add(t2);
            s1 = t1;
            s2 = t2;
        }
        return serialize(root); // Method omitted for brevity
    }
    ```
    
    因此，应该尽量避免使用Java序列化，JSON、Protobuf都是比Java序列化更安全、更简单的序列化方法。
    
    如果因为遗留代码不得不使用Java序列化，应该保证：永远不对不可信来源的字节流进行反序列化。另外，可以利用Java9添加的`java.io.ObjectInputFilter`来对Java序列化进行限制：白名单或者黑名单，正确的用法是规定一个十分有限的白名单，超出此范围的所有类均不允许进行反序列化。